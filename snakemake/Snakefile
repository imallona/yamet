import os.path as op
import glob

# configfile: "config.yaml"
# validate(config, "config.schema.yaml")

## yaml tests start ##########

import yaml

# roadmap ids
# https://egg2.wustl.edu/roadmap/web_portal/meta.html
# https://egg2.wustl.edu/roadmap/web_portal/chr_state_learning.html
# 15 states HMM

config = """
ENCFF112TXF:
 exp: https://www.encodeproject.org/experiments/ENCSR888FON/'
 bam: https://www.encodeproject.org/files/ENCFF112TXF/@@download/ENCFF112TXF.bam
 assembly: GRCh38
 genotype: IMR90
 replicate: 1
 sequencing: single
 roadmap_id: E017
 roadmap_hmm: https://egg2.wustl.edu/roadmap/data/byFileType/chromhmmSegmentations/ChmmModels/coreMarks/jointModel/final/E017_15_coreMarks_hg38lift_mnemonics.bed.gz

ENCFF957OIM:
 exp: https://www.encodeproject.org/experiments/ENCSR881XOU/
 bam: https://www.encodeproject.org/files/ENCFF957OIM/@@download/ENCFF957OIM.bam
 assembly: GRCh38
 genotype: HepG2
 replicate : 1
 sequencing: paired
 roadmap_id : E118
 roadmap_hmm: https://egg2.wustl.edu/roadmap/data/byFileType/chromhmmSegmentations/ChmmModels/coreMarks/jointModel/final/E118_15_coreMarks_hg38lift_mnemonics.bed.gz

ENCFF572KNK :
 exp: https://www.encodeproject.org/experiments/ENCSR881XOU/
 bam: https://www.encodeproject.org/files/ENCFF572KNK/@@download/ENCFF572KNK.bam
 assembly: GRCh38
 genotype: HepG2
 replicate : 2
 sequencing: paired
 roadmap_id : E118
 roadmap_hmm: https://egg2.wustl.edu/roadmap/data/byFileType/chromhmmSegmentations/ChmmModels/coreMarks/jointModel/final/E118_15_coreMarks_hg38lift_mnemonics.bed.gz
"""

config = yaml.load(config)
# print(config)


## yaml tests end ###########


CHROMS = ['chr' + str(c) for c in range(19)]
MINCOVERAGE = 1

SAMPLES = glob.glob(op.join('test_data', '*.bam'))

BAMS = {op.splitext(op.basename(sample))[0] : sample for sample in SAMPLES}

METHTUPLE = expand("{sample}/qnsorted_{sample}_{chrom}.CG.2.tsv",
                    sample =  BAMS.keys(),
                    chrom = CHROMS)



AWK = expand("{sample}/qnsorted_{sample}_{chrom}.CG.2_cov_{cov}.tsv",
                    sample =  BAMS.keys(),
                    chrom = CHROMS,
                    cov = MINCOVERAGE)
ENTROPIES = expand("{sample}/qnsorted_{sample}_{chrom}_cov_{cov}_entropy.bed",
                    sample =  BAMS.keys(),
                    chrom = CHROMS,
                    cov = MINCOVERAGE)
METHYLATIONS = expand("{sample}/qnsorted_{sample}_{chrom}_cov_{cov}_methylation.bed",
                    sample =  BAMS.keys(),
                    chrom = CHROMS,
                    cov = MINCOVERAGE)

MERGED_ENTROPY = expand( "{sample}/{sample}_cov_{cov}_entropy.bed.gz",
                           sample = BAMS.keys(),
                           cov = MINCOVERAGE)
MERGED_METHYLATION = expand( "{sample}/{sample}_cov_{cov}_methylation.bed.gz",
                              sample = BAMS.keys(),
                              cov = MINCOVERAGE)

KNITTED_REPORT = expand("{sample}/01_data_visualization_{sample}_cov_{cov}.html",
                        sample = BAMS.keys(),
                        cov = MINCOVERAGE)
                        

# HMMS_TO_DOWNLOAD = expand("hmms/hmm_{encode}",
#                           encode = [op.basename(config[sample]['roadmap_hmm']) for sample in config.keys()])

print(CHROMS)
print(SAMPLES)
print(HMMS_TO_DOWNLOAD)

rule all:
    input:
        MERGED_ENTROPY, MERGED_METHYLATION, KNITTED_REPORT

rule knit_report:
    input:
        MERGED_ENTROPY, MERGED_METHYLATION
        
    output:
        "{sample}/01_data_visualization_{sample}_cov_{cov}.html"
    script:
        "scripts/01_data_visualization.Rmd"


## for this proper hmm must be downloaded
rule annotate_to_hmm:
    input:
        "{sample}/{sample}_cov_{MINCOVERAGE}_entropy.bed.gz"
    output:
        "{sample}/{sample}_cov_{MINCOVERAGE}_entropy_colored.bed.gz"
    shell:
        "echo 'todo' > {output}"
        
rule merge_methylations:
    input:
        METHYLATIONS
    output:
        "{sample}/{sample}_cov_{MINCOVERAGE}_methylation.bed.gz"
    shell:
        "cat {input} | bedtools sort | gzip > {output}"
        
rule merge_entropies:
    input:
        ENTROPIES
    output:
        "{sample}/{sample}_cov_{MINCOVERAGE}_entropy.bed.gz"
    shell:
        "cat {input} | bedtools sort | gzip > {output}"
        
rule get_methylation:
    input:
        "{sample}/qnsorted_{sample}_{chrom}.CG.2_cov_{MINCOVERAGE}.tsv"
    output:
        temp("{sample}/qnsorted_{sample}_{chrom}_cov_{MINCOVERAGE}_methylation.bed")
    shell:
        """
        awk '
BEGIN {{OFS=FS="\t"}}
NR == 1 {{next}}
{{
  print $1,$3,$4,"MM"$5";MU"$6";UM"$7";UU"$8,(($5+(0.5*$6)+(0.5*$7))/($5+$6+$7+$8))*1000,$2
}}' {input} > {output}
"""

    
rule get_entropy:
    input:
        "{sample}/qnsorted_{sample}_{chrom}.CG.2_cov_{MINCOVERAGE}.tsv"
    output:
        temp("{sample}/qnsorted_{sample}_{chrom}_cov_{MINCOVERAGE}_entropy.bed")
    shell:
        """
        awk '
BEGIN {{OFS=FS="\t"}}
NR == 1 {{next}}
{{
  H["MM"] = $5
  H["UU"] = $8
  H["UM"] = $7
  H["MU"] = $6
  N  = ($5+$6+$7+$8)
  E = 0
  p = ""
  for (i in H) {{
    if (H[i] != 0) {{
      p = H[i]/N;
      E -=  p * log(p);
    }}
  }}

  print $1,$3,$4,"MM"$5";MU"$6";UM"$7";UU"$8,E,$2

}}' {input} > {output}
"""

rule filter_by_coverage:
       input:
           "{sample}/qnsorted_{sample}_{chrom}.CG.2.tsv"
       output:
           temp("{sample}/qnsorted_{sample}_{chrom}.CG.2_cov_{MINCOVERAGE}.tsv")
       shell:
           """
           awk -v mincov="{MINCOVERAGE}" '
           NR == 1 {{next}}
           {{
            if (($5+$6+$7+$8) >= mincov) print $0
           }}' {input} > {output}
           """
                   
rule run_meththuple:
    input:
        "{sample}/qnsorted_{sample}_{chrom}.bam"
    output:
        temp("{sample}/qnsorted_{sample}_{chrom}.CG.2.tsv")
    shell: """
        set +u;
        source ~/virtenvs/methtuple/bin/activate
        methtuple -m 2 --methylation-type CG {input}    
        deactivate
        set -u;
        """
    
rule sort_by_queryname:
    input:
        "{sample}/{sample}_{chrom}.bam"
    output:
        temp("{sample}/qnsorted_{sample}_{chrom}.bam")
        
    shell:
        """
        samtools sort -n {input} {output}
        mv {output}.bam {output}"""

    
rule split_by_chrom:
    input:
        "{sample}/{sample}.bam"
        # lambda wildcards, attempt: attempt * 100
    output:
        temp("{sample}/{sample}_{chrom}.bam")
    shell:
        "samtools view -b {input} {wildcards.chrom} > {output}"
 
rule samtools_sort:
    input:
        "test_data/{sample}.bam"
    output:
        temp("{sample}/{sample}.bam")
    shell:
        """
        samtools sort {input} {output}
        mv {output}.bam {output}
        samtools index {output}
        """

# rule download_hmm:
#     # input:
#     #     [config[sample]['roadmap_hmm'] for sample in config.keys()]
#     output:
#         "{encode}"
#     shell:
#         "wget --quiet {output} -O hmm/{output}"
        
