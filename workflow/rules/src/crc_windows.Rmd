---
title: "CRC by genomic tiles, aggregated and unaggregated single cells"
author: "Izaskun Mallona"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    code_download: true
    number_sections: true
    df_print: default # kable
    theme: lumen
---

```{r, setup}
suppressPackageStartupMessages({
  library(readr)
  library(lmerTest)
  library(ggplot2)
  library(knitr)
  library(ComplexHeatmap)
  library(viridis)
  library(tidyr)
  library(Matrix)
  library(limma)
  library(BiocParallel)
  library(circlize)

  library(dplyr)
  library(purrr)
  library(uwot)  # UMAP

  library(SingleCellExperiment)
  library(SummarizedExperiment)
})

source("src/ggtheme.R")
param <- MulticoreParam(workers = snakemake@threads)
```

```{r}
opts_chunk$set(
  fig.width = 7.5,
  fig.height = 7.5,
  cache = TRUE,
  include = TRUE,
  fig.path = "crc_windows_plots/",
  dev = c("png", "svg"),
  cache.lazy = FALSE,
  warning = TRUE,
  message = TRUE
)

## render on error hook
knitr::knit_hooks$set(error = function(x, options) {
  knitr::knit_exit()
})
```

```{r save_snmk_object_for_debugging, include = FALSE, eval = TRUE}
saveRDS(file = 'snmk_object_windows.rds', object = snakemake)
```

```{r logging, include = FALSE}
log <- file(snakemake@log$log, open = "wt")
sink(log)
sink(log, type = "message")
```

# QC: tile annotations  {.tabset .tabset-pills}

To double check annotations are ok.

Caution downsampling

```{r, fig.width = 12, fig.height = 6}
NROWS <- 1e4

annot <- read_tsv(
  snakemake@input[["annotations"]],
  n_max = NROWS, show_col_types = FALSE
)

mannot <- head(annot, NROWS)
rownames(annot) <- paste0("w", rownames(annot))

plot(hclust(dist(t(mannot))))
```

```{r read_shannons}
filepaths <- list.files(
  snakemake@params[["output_path"]],
  pattern = paste0(
    snakemake@wildcards[["win_size"]], "_(.*)\\.det\\.out\\.gz$"
  ), full.names = TRUE
)

regex <- "(.*)_(.*)_(.*).det.out.gz"
process_reports <- function(filepath) {
  filename <- basename(filepath)
  patient <- gsub(regex, "\\2", filename)
  location <- gsub(regex, "\\3", filename)

  dt <- read_tsv(
    filepath,
    na = "-1", n_max = NROWS,
    show_col_types = FALSE
  )

  ## shannons + avgmeth
  dtm <- dt[, c("shannon", "avg_meth")] |>
    mutate(patient = patient, location = location,
           window = paste0("w", rownames(dt)))
  
  ## sampen
  cols <- grep("singleC", colnames(dt), value = TRUE)
  rows <- paste0("w", seq_len(nrow(dt)))
  se <- as(as.matrix(dt[, cols]), "dgCMatrix")
  dimnames(se) <- list(rows, cols)

  return(list(
    shannon = dtm,
    sampen = list(
      file = filepath,
      patient = patient,
      location = location,
      sampen = se
    )
  ))
}
```

```{r}
## aggregate
shannons <- do.call(
  rbind, bplapply(filepaths, \(x) process_reports(x)$shannon, BPPARAM = param)
)

shannons$patient <- as.factor(shannons$patient)
shannons$location <- factor(
  shannons$location,
  levels = c("NC", "PT", "LN", "ML", "MP", "MO")
)
rownames(shannons) <- paste(
  shannons$patient, shannons$location, rownames(shannons),
  sep = "_"
)

sampens <- lapply(filepaths, \(x) process_reports(x)$sampen)
```


# Single cell visualization/ UMAP and SCE generation {.tabset} {.tabset-pills}

```{r}

# flatten sampens
flatten_entry <- function(entry, filter) {
  mat <- as.matrix(entry$sampen)   # to dense
  df <- as.data.frame(t(mat))      # cells as rows
  df$cell <- colnames(entry$sampen)
  df$patient <- entry$patient
  df$location <- entry$location
  df
}

df_all <- map_dfr(sampens, flatten_entry)
## dim(df_all)
## df_all[1:3, 1:3]

features <- df_all %>% select(starts_with("w"))

# drop windows with >20% NAs
keep_cols <- colMeans(is.na(features)) < 0.2
features <- features[, keep_cols]

# drop cells with >20% NAs
keep_rows <- rowMeans(is.na(features)) < 0.2
features <- features[keep_rows, ]
df_all_filtered <- df_all[keep_rows, ]

# impute remaining NAs

for (j in seq_len(ncol(features))) {
  col_mean <- mean(features[[j]], na.rm = TRUE)
  features[[j]][is.na(features[[j]])] <- col_mean
}

## dim(features)

set.seed(123)
umap_coords <- umap(features, n_neighbors = 15, min_dist = 0.3, metric = "euclidean")

## plus feature rowdata
plot_df <- cbind(as.data.frame(umap_coords),
                 cell = df_all_filtered$cell,
                 patient = df_all_filtered$patient,
                 location = df_all_filtered$location)
```

## UMAP by location (sampEn)

```{r, fig.width = 5, fig.height = 5}
ggplot(plot_df, aes(x = V1, y = V2, color = location)) +
  geom_point(alpha = 1) +
  theme_ng()
```


## UMAP by patient (sampEn)

```{r, fig.width = 5, fig.height = 5}
ggplot(plot_df, aes(x = V1, y = V2, color = patient)) +
  geom_point(alpha = 1) +
  theme_ng()
```

And this is with all features; what would it happen if focusing in changing windows only?

## Violins {.tabset} {.tabset-pills}

### Mean sampEn

```{r}
cell_summary <- features %>%
  as.data.frame() %>%
  mutate(mean_sampen = rowMeans(., na.rm = TRUE),
         var_sampen  = apply(., 1, var, na.rm = TRUE)) %>%
  select(mean_sampen, var_sampen) %>%
  bind_cols(df_all_filtered %>% select(cell, patient, location))

ggplot(cell_summary, aes(x = location, y = mean_sampen, fill = location)) +
  geom_violin(trim = FALSE, scale = "width") +
  geom_boxplot(width = 0.1, outlier.size = 0.5, alpha = 0.5) +
  facet_wrap(~patient) +
  theme_minimal() +
  labs(title = "Per-cell mean entropy by patient and location",
       x = "Location", y = "Mean sample entropy")
```

### Var sampEn

```{r}
ggplot(cell_summary, aes(x = location, y = var_sampen, fill = location)) +
  geom_violin(trim = FALSE, scale = "width") +
  geom_boxplot(width = 0.1, outlier.size = 0.5, alpha = 0.5) +
  facet_wrap(~patient) +
  theme_minimal() +
  labs(title = "Per-cell entropy variance by patient and location",
       x = "Location", y = "Variance of sample entropy")

```

## Export SCE

Export a SCE (again with some filtering for NAs and some imputation)

```{r}

assay_list <- list(sampen = t(as.matrix(features)))

# Add summary stats
df_all_filtered <- df_all_filtered |>
   mutate(
       mean_sampen = rowMeans(features, na.rm = TRUE),
       var_sampen  = apply(features, 1, var, na.rm = TRUE))

col_data <- data.frame(df_all_filtered[,c('cell', 'patient', 'location', 'mean_sampen', 'var_sampen')])
## row_data <- data.frame(annot[colnames(features), ])
row_data <- annot[colnames(features), , drop = FALSE]
rownames(row_data) <- colnames(features)

sce <- SingleCellExperiment(
  assays = assay_list,
  colData = col_data,
  rowData = row_data
)

# add assay with DNA meth as well

filepaths <- list.files(
  snakemake@params[["output_path"]],
  pattern = paste0(
    snakemake@wildcards[["win_size"]], "_(.*)\\.meth\\.out\\.gz$"
  ), full.names = TRUE
)

regex <- "(.*)_(.*)_(.*).meth.out.gz"

process_meth_reports <- function(filepath) {
  filename <- basename(filepath)
  patient <- gsub(regex, "\\2", filename)
  location <- gsub(regex, "\\3", filename)

  dt <- read_tsv(
    filepath,
    na = "-1", n_max = NROWS,
    show_col_types = FALSE
  )

  ## sampens
  cols <- grep("singleC", colnames(dt), value = TRUE)
  se <- as(as.matrix(dt[, cols]), "dgCMatrix")
  dimnames(se) <- list(paste0("w", seq_len(nrow(dt))), cols)

  return(list(
    meth = list(
      file = filepath,
      patient = patient,
      location = location,
      meth = se
    )
  ))
}

meths <- lapply(filepaths, \(x) process_meth_reports(x)$meth)
meth_mats <- lapply(meths, function(x) x$meth)
meth_mat <- do.call(cbind, meth_mats)
## meth_mats <- map(filepaths, \(x) process_meth_reports(x)$meth)
## meth_mat  <- do.call(cbind, meth_mats)
rm(meth_mats)

# align with the other assay
meth_mat <- meth_mat[rownames(sce), colnames(assay(sce, "sampen"))]

stopifnot(
  identical(rownames(assay(sce, "sampen")), rownames(meth_mat)),
  identical(colnames(assay(sce, "sampen")), colnames(meth_mat)))

assay(sce, "meth") <- meth_mat

rm(meth_mat)

saveRDS('sce_windows_colon.rds', object = sce)
```

# QC  {.tabset .tabset-pills}

Back to the SCE-free plotting/reports

```{r}
## let's get a value per window - median
sampens <- bplapply(sampens, \(x) {
  x$median <- apply(
    x$sampen, 1, function(x) median(x, na.rm = TRUE)
  ) # median sampEn per window/genomic tile
  x$range <- suppressWarnings(
    apply(x$sampen, 1, function(x) max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
  )
  x
}, BPPARAM = param)
```


## By location - Shannon

```{r, fig.width = 10, fig.height = 10}
par(mfrow = c(3, 2), pty = "s")
for (loc in levels(shannons$location)) {
  tmp <- shannons[shannons$location == loc, ]
  plot(shannon ~ avg_meth, col = as.numeric(as.factor(tmp$location)), pch = ".", data = tmp, main = loc)
}
```


## By patient (colored by location as before) - Shannon

```{r, fig.width = 10, fig.height = 10}
par(mfrow = c(3, 3), pty = "s")
for (patient in levels(shannons$patient)) {
  tmp <- shannons[shannons$patient == patient, ]
  plot(shannon ~ avg_meth, col = as.numeric(as.factor(tmp$location)), pch = ".", data = tmp, main = patient[1])
}
```

## By patient and location - Shannon

```{r, fig.width =8, fig.height = 11}
par(mfrow = c(4, 4), pty = "s")
for (patient in levels(shannons$patient)) {
  tmp <- shannons[shannons$patient == patient, ]
  for (loc in unique(tmp$location)) {
    tmp <- shannons[shannons$patient == patient & shannons$location == loc, ]
    plot(shannon ~ avg_meth,
      col = as.numeric(as.factor(tmp$location)),
      pch = ".", data = tmp, main = paste(loc, patient[1])
    )
  }
}
```

<!-- # Nonfinal heatmaps {.tabset .tabset-pills} -->


<!-- ## Median sampens -->

<!-- Mind each column should be a miniheatmap instead, not depicting a median -->

<!-- ```{r firstheatmap, fig.width = 14, fig.height = 10} -->
<!-- med_sampens <- as.matrix(do.call(cbind.data.frame, lapply(sampens, function(x) { -->
<!--   return(x$median) -->
<!-- }))) -->
<!-- colnames(med_sampens) <- bplapply(sampens, \(x) x$file, BPPARAM = param) -->

<!-- # hist(apply(med_sampens, 1, function(x) sum(is.na(x)))) -->

<!-- # remove windows with more than 50 missing values -->
<!-- # med_sampens <- med_sampens[apply(med_sampens, 1, function(x) sum(is.na(x))) < 50,] -->
<!-- ## dim(na.omit(med_sampens)) -->
<!-- ## rather all nas go out -->

<!-- med_sampens <- na.omit(med_sampens) -->

<!-- column_ha <- HeatmapAnnotation( -->
<!--   patient = gsub(regex, "\\2", basename(colnames(med_sampens))), -->
<!--   location = gsub(regex, "\\3", basename(colnames(med_sampens))) -->
<!-- ) -->

<!-- row_ha <- rowAnnotation(tile_annotation = as.matrix(data.frame( -->
<!--   genes = annot[rownames(med_sampens), "genes_genes"], -->
<!--   islands = annot[rownames(med_sampens), "cpgIslandExt_cpgIslandExt"],                      -->

<!--   pmd = annot[rownames(med_sampens), "pmds_pmd"], -->
<!--   hmd = annot[rownames(med_sampens), "hmds_pmd"], -->

<!--   scna_nc = annot[rownames(med_sampens), "crc01_nc_scna_scna"], -->
<!--   scna_gain = annot[rownames(med_sampens), "crc01_gain_scna_scna"], -->
<!--   scna_loss = annot[rownames(med_sampens), "crc01_lost_scna_scna"],   -->

<!--   H3K27me3 = annot[rownames(med_sampens), "H3K27me3_chip"], -->
<!--   H3K9me3 = annot[rownames(med_sampens), "H3K9me3_chip"], -->
<!--   H3K4me3 = annot[rownames(med_sampens), "H3K4me3_chip"], -->
<!--   laminb1 = annot[rownames(med_sampens), "laminb1_lad"], -->
  
<!--   X0_Enhancer_hmm = annot[rownames(med_sampens), "0_Enhancer_hmm"], -->
<!--   X2_Enhancer_hmm = annot[rownames(med_sampens), "2_Enhancer_hmm"], -->
<!--   X1_Transcribed_hmm = annot[rownames(med_sampens), "1_Transcribed_hmm"], -->
<!--   X4_Transcribed_hmm = annot[rownames(med_sampens), "4_Transcribed_hmm"], -->
<!--   X5_RegPermissive_hmm = annot[rownames(med_sampens), "5_RegPermissive_hmm"], -->
<!--   X7_RegPermissive_hmm = annot[rownames(med_sampens), "7_RegPermissive_hmm"], -->
  
<!--   X3_Quiescent = annot[rownames(med_sampens), "3_Quiescent_hmm"], -->
<!--   X8_Quiescent = annot[rownames(med_sampens), "8_Quiescent_hmm"], -->
<!--   X10_Quiescent = annot[rownames(med_sampens), "10_Quiescent_hmm"], -->

<!--   X11_Promoter = annot[rownames(med_sampens), "11_Promoter_hmm"], -->
<!--   X12_Promoter = annot[rownames(med_sampens), "12_Promoter_hmm"], -->

<!--   X9_ConstitutiveHet = annot[rownames(med_sampens), "9_ConstitutiveHet_hmm"], -->
<!--   X13_ConstitutiveHet = annot[rownames(med_sampens), "13_ConstitutiveHet_hmm"], -->
  
<!--   X6_LowConfidence = annot[rownames(med_sampens), "6_LowConfidence_hmm"] -->
<!-- ))) -->

<!-- Heatmap(med_sampens, -->
<!--   name = "med sampens", -->
<!--   top_annotation = column_ha, -->
<!--   right_annotation = row_ha, -->
<!--   show_row_names = FALSE, -->
<!--   column_labels = gsub(".det.out", "", basename(colnames(med_sampens))) -->
<!-- ) -->
<!-- ``` -->

<!-- ## Plus Shannons tile margin -->

<!-- Let's add the shannons, out of curiosity -->

<!-- ```{r, fig.width = 15, fig.height = 10, eval = TRUE} -->
<!-- shannons_wide <- as.data.frame(pivot_wider(shannons, -->
<!--   id_cols = "window", -->
<!--   names_from = c("patient", "location"), -->
<!--   values_from = "shannon" -->
<!-- )) -->

<!-- rownames(shannons_wide) <- shannons_wide$window -->
<!-- shannons_wide <- shannons_wide[, grep( -->
<!--   "window", colnames(shannons_wide), -->
<!--   invert = TRUE -->
<!-- )] -->

<!-- ## clust samples by shannon; that's to order the cols for the lefthand annot heatmap to the main heatmap -->

<!-- tmp <- t(as.matrix(shannons_wide)[rownames(med_sampens), ]) -->
<!-- tmp.hc <- hclust(dist(tmp)) -->

<!-- row_shannons <- rowAnnotation( -->
<!--   shannons = as.matrix(shannons_wide)[rownames(med_sampens), tmp.hc$order], -->
<!--   width = ncol(med_sampens) * unit(3, "mm") -->
<!-- ) -->

<!-- Heatmap(med_sampens, -->
<!--   name = "med sampens", -->
<!--   top_annotation = column_ha, -->
<!--   right_annotation = row_ha, -->
<!--   left_annotation = row_shannons, -->
<!--   show_row_names = FALSE, -->
<!--   column_labels = gsub(".det.out.gz", "", basename(colnames(med_sampens))), -->
<!--   width = ncol(med_sampens) * unit(9, "mm") -->
<!-- ) -->
<!-- ``` -->

<!-- ## Range sampens -->

<!-- If Shannon is high we're interested in knowing the range of sampEns. -->

<!-- ```{r, fig.width = 15, fig.height = 10} -->
<!-- range_sampens <- as.matrix( -->
<!--   do.call(cbind.data.frame, lapply(sampens, \(x) x$range)) -->
<!-- ) -->
<!-- colnames(range_sampens) <- lapply(sampens, \(x) x$file) -->

<!-- rownames(range_sampens) <- paste0("w", seq_len(nrow(range_sampens))) -->
<!-- range_sampens[!is.finite(range_sampens)] <- NA -->

<!-- range_sampens <- na.omit(range_sampens) -->

<!-- Heatmap(range_sampens, -->
<!--   name = "range sampens", -->
<!--   top_annotation = column_ha, -->
<!--   right_annotation = row_ha, -->
<!--   left_annotation = row_shannons, -->
<!--   show_row_names = FALSE, -->
<!--   column_labels = gsub(".det.out.gz", "", basename(colnames(range_sampens))), -->
<!--   width = ncol(range_sampens) * unit(9, "mm") -->
<!-- ) -->
<!-- ``` -->


<!-- ## Rather cluster the Shannon's and add sampEns as tile margins -->

<!-- What if clustering the shannon's instead, and annotating the avg sampens? -->

<!-- ```{r, fig.width = 18, fig.height = 10, eval = TRUE} -->
<!-- curr_shannons <- as.matrix(shannons_wide)[rownames(med_sampens), ] -->

<!-- col_ha <- HeatmapAnnotation( -->
<!--   patient = gsub("(.*)_(.*)", "\\1", basename(colnames(curr_shannons))), -->
<!--   location = gsub("(.*)_(.*)", "\\2", basename(colnames(curr_shannons))) -->
<!-- ) -->

<!-- colnames(med_sampens) <- gsub( -->
<!--   ".det.out.gz", "", basename(colnames(med_sampens)) -->
<!-- ) -->
<!-- row_med_sampens <- rowAnnotation(med_sampens = med_sampens) -->

<!-- Heatmap(curr_shannons, -->
<!--   name = "shannons", -->
<!--   top_annotation = col_ha, -->
<!--   left_annotation = row_med_sampens, -->
<!--   right_annotation = row_ha, -->
<!--   show_row_names = FALSE -->
<!-- ) -->
<!-- ``` -->

# Atreya's stats

As in  https://github.com/imallona/yamet/blob/857bc788d711b26cd64b8ca4586ca2c3927900c4/workflow/rules/src/crc_stats.Rmd etc.


We reread everything from scratch (!); todo streamline.

```{r}
filepaths <- list.files(
  snakemake@params[["output_path"]],
  pattern = paste0(
    snakemake@wildcards[["win_size"]], "_(.*)\\.det\\.out\\.gz$"
  ), full.names = TRUE
)

process_reports <- function(filepath) {
  out_path <- gsub("\\.det", "", filepath)
  m_out_path <- gsub("\\.det\\.", ".meth.", filepath)

  out <- read_tsv(out_path, show_col_types = FALSE, na = "-1")
  se <- read_tsv(filepath, show_col_types = FALSE, na = "-1")
  ms <- read_tsv(m_out_path, show_col_types = FALSE, na = "-1")

  rwnms <- paste0(se$chr, ":", se$start, "-", se$end)

  shannon <- se[, c("shannon", "avg_meth")]

  se <- as.matrix(se[, grep("singleC", colnames(se))])
  ms <- as.matrix(ms[, grep("singleC", colnames(ms))])

  rownames(se) <- rwnms
  rownames(ms) <- rwnms

  return(
    list(
      shannon = shannon,
      sampen = se, meth = ms, cell_meth = out$avg_meth
    )
  )
}

all_data <- bplapply(filepaths, process_reports, BPPARAM = param)
sampens <- do.call(cbind, lapply(all_data, \(x) x$sampen))
meths <- do.call(cbind, lapply(all_data, \(x) x$meth))

annot <- read_tsv(snakemake@input[["annotations"]], show_col_types = FALSE)
rownames(annot) <- rownames(sampens)

get_row_annotations <- function(regions) {
  rowAnnotation(tile_annotation = as.matrix(data.frame(
    ## pmd = annot[regions, "pmds_pmd"],
    ## hmd = annot[regions, "hmds_pmd"],
    ## H3K27me3 = annot[regions, "H3K27me3_chip"],
    ## H3K9me3 = annot[regions, "H3K9me3_chip"],
    ## H3K4me3 = annot[regions, "H3K4me3_chip"],
    ## laminb1 = annot[regions, "laminb1_lad"],
    ## X8_Quiescent = annot[regions, "8_Quiescent_hmm"]
  genes = annot[rownames(med_sampens), "genes_genes"],
  islands = annot[rownames(med_sampens), "cpgIslandExt_cpgIslandExt"],                     

  pmd = annot[rownames(med_sampens), "pmds_pmd"],
  hmd = annot[rownames(med_sampens), "hmds_pmd"],

  scna_nc = annot[rownames(med_sampens), "crc01_nc_scna_scna"],
  scna_gain = annot[rownames(med_sampens), "crc01_gain_scna_scna"],
  scna_loss = annot[rownames(med_sampens), "crc01_lost_scna_scna"],  

  H3K27me3 = annot[rownames(med_sampens), "H3K27me3_chip"],
  H3K9me3 = annot[rownames(med_sampens), "H3K9me3_chip"],
  H3K4me3 = annot[rownames(med_sampens), "H3K4me3_chip"],
  laminb1 = annot[rownames(med_sampens), "laminb1_lad"],
  
  X0_Enhancer_hmm = annot[rownames(med_sampens), "0_Enhancer_hmm"],
  X2_Enhancer_hmm = annot[rownames(med_sampens), "2_Enhancer_hmm"],
  X1_Transcribed_hmm = annot[rownames(med_sampens), "1_Transcribed_hmm"],
  X4_Transcribed_hmm = annot[rownames(med_sampens), "4_Transcribed_hmm"],
  X5_RegPermissive_hmm = annot[rownames(med_sampens), "5_RegPermissive_hmm"],
  X7_RegPermissive_hmm = annot[rownames(med_sampens), "7_RegPermissive_hmm"],
  
  X3_Quiescent = annot[rownames(med_sampens), "3_Quiescent_hmm"],
  X8_Quiescent = annot[rownames(med_sampens), "8_Quiescent_hmm"],
  X10_Quiescent = annot[rownames(med_sampens), "10_Quiescent_hmm"],

  X11_Promoter = annot[rownames(med_sampens), "11_Promoter_hmm"],
  X12_Promoter = annot[rownames(med_sampens), "12_Promoter_hmm"],

  X9_ConstitutiveHet = annot[rownames(med_sampens), "9_ConstitutiveHet_hmm"],
  X13_ConstitutiveHet = annot[rownames(med_sampens), "13_ConstitutiveHet_hmm"],
  
  X6_LowConfidence = annot[rownames(med_sampens), "6_LowConfidence_hmm"]
  
  )))
}

meta <- data.frame(
  colname = colnames(sampens),
  patient = sapply(strsplit(colnames(sampens), "_"), \(x) x[3]),
  subloc = sapply(strsplit(colnames(sampens), "_"), \(x) x[4]),
  cell_meth = unlist(lapply(all_data, \(x) x$cell_meth), recursive = FALSE)
)
meta$loc <- substr(meta$subloc, 1, 2)
meta$loc <- relevel(factor(meta$loc), ref = "NC")
meta <- meta[order(as.integer(meta$loc), meta$subloc, meta$patient), ]
sampens <- sampens[, meta$colname]
meths <- meths[, meta$colname]

groups <- unique(meta[c("subloc", "patient")])
groups <- groups[
  order(substr(groups$subloc, 1, 2), groups$subloc, groups$patient),
]
sub_sampens <- do.call(cbind, lapply(seq_len(nrow(groups)), \(i) {
  cols <- meta$colname[
    meta$patient == groups$patient[i] & meta$subloc == groups$subloc[i]
  ]
  rowMeans(sampens[, cols, drop = FALSE], na.rm = TRUE)
}))
colnames(sub_sampens) <- paste(groups$subloc, groups$patient, sep = "_")

sub_meths <- do.call(cbind, lapply(seq_len(nrow(groups)), \(i) {
  cols <- meta$colname[
    meta$patient == groups$patient[i] & meta$subloc == groups$subloc[i]
  ]
  rowMeans(meths[, cols, drop = FALSE], na.rm = TRUE)
}))
colnames(sub_meths) <- paste(groups$subloc, groups$patient, sep = "_")
```

So these data group entropies/sampens from different biopsy:patient pairs

```{r}
str(sub_meths)
str(sub_sampens)
```

```{r}
row_na_frac <- \(x) mean(is.na(x)) >= 0.5
rows_too_sparse <- apply(sub_sampens, 1, row_na_frac) |
  apply(sub_meths, 1, row_na_frac)

## dim(sub_sampens)
## dim(sub_meths)

sub_sampens <- sub_sampens[!rows_too_sparse, , drop = FALSE]
sub_meths <- sub_meths[!rows_too_sparse, , drop = FALSE]

## dim(sub_sampens)
## dim(sub_meths)

colnames(sub_meths)
```



```{r}
c02_nc <- data.frame(y = sub_sampens[, "NC_CRC02"], x = sub_meths[, "NC_CRC02"])
c02_nc <- na.omit(c02_nc)
sampled_data <- c02_nc[sample(nrow(c02_nc), 5000), ]

ggplot(sampled_data, aes(x = x, y = y)) +
  geom_point(alpha = 0.6, size = 0.6) +
  labs(
    title = "Adjacent normal in CRC02",
    x = "average methylation",
    y = "Sample entropy"
  ) +
  theme_ng()
```


Let's do a Window-wise sampEn vs meth with loc and patient, regardless of the annotation of the window. Mind the quadratic meth term (not sure what for).

```{r}
rowwise_lm <- function(i) {
  df <- data.frame(
    sampen = sub_sampens[i, ],
    meth = sub_meths[i, ],
    loc = factor(substr(groups$subloc, 1, 2)),
    patient = groups$patient
  )
  df$loc <- relevel(df$loc, ref = "NC")

  fit <- try(lm(sampen ~ meth + I(meth^2) + loc + patient, data = df), silent = T)
  s <- summary(fit)$coefficients

  if (!("locPT" %in% rownames(s))) {
    return(rep(NA, 5))
  }

  c(
    estimate  = s["locPT", "Estimate"],
    std_error = s["locPT", "Std. Error"],
    t_value   = s["locPT", "t value"],
    p_value   = s["locPT", "Pr(>|t|)"],
    df        = df.residual(fit)
  )
}

coefs_list <- bplapply(seq_len(nrow(sub_sampens)), rowwise_lm, BPPARAM = param)
head(coefs_list)

coefs_df <- do.call(rbind, coefs_list)
colnames(coefs_df) <- c("estimate", "std_error", "t_value", "p_value", "df")
coefs_df <- as.data.frame(coefs_df)

## head(coefs_df)

## dim(coefs_df)

coefs_df[] <- lapply(coefs_df, as.numeric)

valid <- complete.cases(coefs_df)
coefs_valid <- coefs_df[valid, ]

## dim(coefs_valid)

s2 <- coefs_valid$std_error^2
df_resid <- coefs_valid$df
squeezed <- squeezeVar(var = s2, df = df_resid)

moderated_t <- coefs_valid$estimate / sqrt(squeezed$var.post)
moderated_p <- 2 * pt(-abs(moderated_t), df = squeezed$df.prior + df_resid)
adj_p <- p.adjust(moderated_p, method = "BH")

coefs_valid$moderated_t <- moderated_t
coefs_valid$moderated_p <- moderated_p
coefs_valid$adj_p <- adj_p

coefs_df$moderated_t <- NA
coefs_df$moderated_p <- NA
coefs_df$adj_p <- NA
coefs_df[
  valid, c("moderated_t", "moderated_p", "adj_p")
] <- coefs_valid[, c("moderated_t", "moderated_p", "adj_p")]

## dim(coefs_df)
head(coefs_df)

coefs_df$region <- rownames(sub_sampens)

saveRDS(object = coefs_df, 'atreyas_coefs.rds')

table(coefs_df$adj_p < 0.05)
hist(coefs_df$adj_p)

sorted_idx <- order(coefs_df$adj_p, na.last = NA)

top_2k_idx <- sorted_idx[1:2000]

top_entropy <- sub_sampens[top_2k_idx, ]
top_meth <- sub_meths[top_2k_idx, ]
## head(top_meth)
```


Let's now add to the row annotation whether regions are top_meth or top_entropy

```{r}
row_ha <- rowAnnotation(tile_annotation = as.matrix(data.frame(

  diff_sampen_atreya = coefs_df$adj_p < 0.05,
  
  genes = annot[coefs_df$region, "genes_genes"],
  islands = annot[coefs_df$region, "cpgIslandExt_cpgIslandExt"],                     

  pmd = annot[coefs_df$region, "pmds_pmd"],
  hmd = annot[coefs_df$region, "hmds_pmd"],

  scna_nc = annot[coefs_df$region, "crc01_nc_scna_scna"],
  scna_gain = annot[coefs_df$region, "crc01_gain_scna_scna"],
  scna_loss = annot[coefs_df$region, "crc01_lost_scna_scna"],  

  H3K27me3 = annot[coefs_df$region, "H3K27me3_chip"],
  H3K9me3 = annot[coefs_df$region, "H3K9me3_chip"],
  H3K4me3 = annot[coefs_df$region, "H3K4me3_chip"],
  laminb1 = annot[coefs_df$region, "laminb1_lad"],
  
  X0_Enhancer_hmm = annot[coefs_df$region, "0_Enhancer_hmm"],
  X2_Enhancer_hmm = annot[coefs_df$region, "2_Enhancer_hmm"],
  X1_Transcribed_hmm = annot[coefs_df$region, "1_Transcribed_hmm"],
  X4_Transcribed_hmm = annot[coefs_df$region, "4_Transcribed_hmm"],
  X5_RegPermissive_hmm = annot[coefs_df$region, "5_RegPermissive_hmm"],
  X7_RegPermissive_hmm = annot[coefs_df$region, "7_RegPermissive_hmm"],
  
  X3_Quiescent = annot[coefs_df$region, "3_Quiescent_hmm"],
  X8_Quiescent = annot[coefs_df$region, "8_Quiescent_hmm"],
  X10_Quiescent = annot[coefs_df$region, "10_Quiescent_hmm"],

  X11_Promoter = annot[coefs_df$region, "11_Promoter_hmm"],
  X12_Promoter = annot[coefs_df$region, "12_Promoter_hmm"],

  X9_ConstitutiveHet = annot[coefs_df$region, "9_ConstitutiveHet_hmm"],
  X13_ConstitutiveHet = annot[coefs_df$region, "13_ConstitutiveHet_hmm"],
  
  X6_LowConfidence = annot[coefs_df$region, "6_LowConfidence_hmm"]
)))
```

# Heatmap including diff entropic

```{r, fig.width =20, fig.height = 10}
## euclidean distance directly
row.hc <- hclust(dist(sub_sampens), method = "ward.D2")

column_ha <- HeatmapAnnotation(
  loc = substr(groups$subloc, 1, 2),
  patient = groups$patient
)

stopifnot(all(rownames(sub_sampens) == rownames(sub_meths)))

# x11()

Heatmap(sub_sampens,
  name = "Sample entropy",
  top_annotation = column_ha,
  right_annotation = row_ha,
  show_row_names = FALSE,
  show_column_names = FALSE,
  cluster_columns = FALSE,
  cluster_rows = row.hc,
)  +  Heatmap(sub_meths,
              name = "DNA methylation",              
              col = colorRamp2(c(0, 1), c("white", "black")),
              show_row_names = FALSE,
              show_column_names = FALSE,
              cluster_columns = FALSE,
              cluster_rows = row.hc)
```


# Atreya's but only PT vs NC


```{r}
rowwise_lm <- function(i) {
  df <- data.frame(
    sampen = sub_sampens[i, ],
    meth = sub_meths[i, ],
    loc = factor(substr(groups$subloc, 1, 2)),
    patient = groups$patient
  )

  df <- df[df$loc %in% c('PT', 'NC'), ]
  df$loc <- relevel(df$loc, ref = "NC")

  fit <- try(lm(sampen ~ meth + I(meth^2) + loc + patient, data = df), silent = T)
  s <- summary(fit)$coefficients

  if (!("locPT" %in% rownames(s))) {
    return(rep(NA, 5))
  }

  c(
    estimate  = s["locPT", "Estimate"],
    std_error = s["locPT", "Std. Error"],
    t_value   = s["locPT", "t value"],
    p_value   = s["locPT", "Pr(>|t|)"],
    df        = df.residual(fit)
  )
}

coefs_list <- bplapply(seq_len(nrow(sub_sampens)), rowwise_lm, BPPARAM = param)
head(coefs_list)

coefs_df <- do.call(rbind, coefs_list)
colnames(coefs_df) <- c("estimate", "std_error", "t_value", "p_value", "df")
coefs_df <- as.data.frame(coefs_df)


coefs_df[] <- lapply(coefs_df, as.numeric)

valid <- complete.cases(coefs_df)
coefs_valid <- coefs_df[valid, ]

## dim(coefs_valid)

s2 <- coefs_valid$std_error^2
df_resid <- coefs_valid$df
squeezed <- squeezeVar(var = s2, df = df_resid)

moderated_t <- coefs_valid$estimate / sqrt(squeezed$var.post)
moderated_p <- 2 * pt(-abs(moderated_t), df = squeezed$df.prior + df_resid)
adj_p <- p.adjust(moderated_p, method = "BH")

coefs_valid$moderated_t <- moderated_t
coefs_valid$moderated_p <- moderated_p
coefs_valid$adj_p <- adj_p

coefs_df$moderated_t <- NA
coefs_df$moderated_p <- NA
coefs_df$adj_p <- NA
coefs_df[
  valid, c("moderated_t", "moderated_p", "adj_p")
] <- coefs_valid[, c("moderated_t", "moderated_p", "adj_p")]

## dim(coefs_df)
head(coefs_df)

coefs_df$region <- rownames(sub_sampens)

saveRDS(object = coefs_df, 'pt_vs_nc_coefs.rds')

table(coefs_df$adj_p < 0.05)
hist(coefs_df$adj_p)

sorted_idx <- order(coefs_df$adj_p, na.last = NA)

top_2k_idx <- sorted_idx[1:2000]

top_entropy <- sub_sampens[top_2k_idx, ]
top_meth <- sub_meths[top_2k_idx, ]
## head(top_meth)
```


# Same but with a function

```{r}
source('diff_testing.R')

# with the quadratic term still

df2 <- data.frame(
    sampen = sub_sampens[i, ],
    meth = sub_meths[i, ],
    loc = factor(substr(groups$subloc, 1, 2)),
    patient = groups$patient
)

df2 <- df[df2$loc %in% c('PT', 'NC'), ]
df2$loc <- relevel(df2$loc, ref = "NC")


res <- diff_entropy_test_df(
  df       = df2,
  formula  = "sampen ~ meth + I(meth^2) + loc + patient",
  param    = param,
  out_file = "pt_vs_nc_coefs.rds",
  top_n    = 2000,
  contrast = "locPT"
)

head(res$coefs_df)
```




## rowData correlations directly, to add diff entropic and stratify per biopsy site

<!-- ```{r, fig.width = 10, fig.height = 10} -->
<!-- ## sce <- readRDS('../../sce_windows_colon.rds') -->
<!-- dim(rowData(sce)) -->
<!-- colnames(rowData(sce)) -->

<!-- rowData(sce)$mean_sampen <- rowMeans(assay(sce, "sampen"), na.rm = TRUE) -->
<!-- rowData(sce)$mean_meth   <- rowMeans(assay(sce, "meth"), na.rm = TRUE) -->

<!-- rowData(sce)$var_sampen <- apply(assay(sce, "sampen"), 1, var, na.rm = TRUE) -->
<!-- rowData(sce)$var_meth   <- apply(assay(sce, "meth"), 1, var, na.rm = TRUE) -->
                                 
<!-- rd <- as.data.frame(rowData(sce)) -->

<!-- cor_mat <- cor(rd, use = "pairwise.complete.obs", method = "spearman") -->

<!-- dist_mat <- as.dist(1 - cor_mat) -->
<!-- hc <- hclust(dist_mat, method = "ward.D2") -->

<!-- col_fun <- colorRamp2(c(-1, 0, 1), c("blue", "white", "red")) -->

<!-- Heatmap(cor_mat, -->
<!--         name = "Window annotation correlation", -->
<!--         col = col_fun, -->
<!--         cluster_rows = TRUE, -->
<!--         cluster_columns = TRUE, -->
<!--         show_row_names = TRUE, -->
<!--         show_column_names = TRUE) -->

<!-- ``` -->

## GO

add 'genes' as a layer to the window annotation and store the id for gene ontology/geneset enrichment (on limma diff entropic regions)


```{r}
sessionInfo()
knitr::knit_exit()
```
