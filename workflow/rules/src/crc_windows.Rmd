---
title: "CRC by genomic tiles, first exploration"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    code_download: true
    number_sections: true
    df_print: default # kable
    theme: lumen
---

```{r, setup}
suppressPackageStartupMessages({
  library(readr)
  library(lmerTest)
  library(ggplot2)
  library(knitr)
  library(ComplexHeatmap)
  library(viridis)
  library(tidyr)
  library(Matrix)
  library(limma)
  library(BiocParallel)
})

source("src/ggtheme.R")
param <- MulticoreParam(workers = snakemake@threads)
```

```{r}
opts_chunk$set(
  fig.width = 7.5,
  fig.height = 7.5,
  cache = FALSE,
  include = TRUE,
  fig.path = "crc_windows_plots/",
  dev = c("png", "svg"),
  cache.lazy = FALSE,
  warning = TRUE,
  message = TRUE
)

## render on error hook
knitr::knit_hooks$set(error = function(x, options) {
  knitr::knit_exit()
})
```

```{r save_snmk_object_for_debugging, include = FALSE}
saveRDS(file = 'snmk_object_windows.rds', object = snakemake)
```

```{r logging, include = FALSE}
log <- file(snakemake@log$log, open = "wt")
sink(log)
sink(log, type = "message")
```

# Tile annotations  {.tabset .tabset-pills}

To double check annotations are ok.

Caution downsampling

```{r downsampling}
NROWS <- 3e4
```

```{r}
annot <- read_tsv(
  snakemake@input[["annotations"]],
  n_max = NROWS, show_col_types = FALSE
)
```


First, cluster the annots to make sure they make sense to start with, without any sampens

```{r, fig.width = 12, fig.height = 6}
mannot <- head(annot, NROWS)
rownames(annot) <- paste0("w", rownames(annot))

plot(hclust(dist(t(mannot))))
```


# QC  {.tabset .tabset-pills}

## Local reports - Shannon {.tabset .tabset-pills}

Caution downsampled

```{r read_shannons}
filepaths <- list.files(
  snakemake@params[["output_path"]],
  pattern = paste0(
    snakemake@wildcards[["win_size"]], "_(.*)\\.det\\.out\\.gz$"
  ), full.names = TRUE
)

head(filepaths)

regex <- "(.*)_(.*)_(.*).det.out.gz"
process_reports <- function(filepath) {
  filename <- basename(filepath)
  patient <- gsub(regex, "\\2", filename)
  location <- gsub(regex, "\\3", filename)

  dt <- read_tsv(
    filepath,
    na = "-1", n_max = NROWS,
    show_col_types = FALSE
  )

  ## shannons
  dtm <- dt[, c("shannon", "avg_meth")]
  dtm$patient <- patient
  dtm$location <- location
  dtm$window <- paste0("w", rownames(dt))

  ## sampens
  cols <- grep("singleC", colnames(dt), value = TRUE)
  rows <- paste0("w", seq_len(nrow(dt)))

  se <- as(as.matrix(dt[, cols]), "dgCMatrix")

  dimnames(se) <- list(rows, cols)

  return(list(
    shannon = dtm,
    sampen = list(
      file = filepath,
      patient = patient,
      location = location,
      sampen = se
    )
  ))
}

## these are mainly shannons! and avgmeths
shannons <- do.call(
  rbind, bplapply(filepaths, \(x) process_reports(x)$shannon, BPPARAM = param)
)

shannons$patient <- as.factor(shannons$patient)
shannons$location <- factor(
  shannons$location,
  levels = c("NC", "PT", "LN", "ML", "MP", "MO")
)
rownames(shannons) <- paste(
  shannons$patient, shannons$location, rownames(shannons),
  sep = "_"
)


sampens <- lapply(filepaths, \(x) process_reports(x)$sampen)

## let's get a value per window - median
sampens <- bplapply(sampens, \(x) {
  x$median <- apply(
    x$sampen, 1, function(x) median(x, na.rm = TRUE)
  ) # median sampEn per window/genomic tile
  x$range <- suppressWarnings(
    apply(x$sampen, 1, function(x) max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
  )
  x
}, BPPARAM = param)
```

## By location 

```{r, fig.width = 10, fig.height = 10}
par(mfrow = c(3, 2), pty = "s")
for (loc in levels(shannons$location)) {
  tmp <- shannons[shannons$location == loc, ]
  plot(shannon ~ avg_meth, col = as.numeric(as.factor(tmp$location)), pch = ".", data = tmp, main = loc)
}
```


## By patient (colored by location as before)

```{r, fig.width = 10, fig.height = 10}
par(mfrow = c(3, 3), pty = "s")
for (patient in levels(shannons$patient)) {
  tmp <- shannons[shannons$patient == patient, ]
  plot(shannon ~ avg_meth, col = as.numeric(as.factor(tmp$location)), pch = ".", data = tmp, main = patient[1])
}
```

## By patient and location

```{r, fig.width =8, fig.height = 11}
par(mfrow = c(4, 4), pty = "s")
for (patient in levels(shannons$patient)) {
  tmp <- shannons[shannons$patient == patient, ]
  for (loc in unique(tmp$location)) {
    tmp <- shannons[shannons$patient == patient & shannons$location == loc, ]
    plot(shannon ~ avg_meth,
      col = as.numeric(as.factor(tmp$location)),
      pch = ".", data = tmp, main = paste(loc, patient[1])
    )
  }
}
```

# Heatmaps {.tabset .tabset-pills}


## Median sampens

Mind each column should be a miniheatmap instead, not depicting a median

```{r, fig.width = 10, fig.height = 10}
med_sampens <- as.matrix(do.call(cbind.data.frame, lapply(sampens, function(x) {
  return(x$median)
})))
colnames(med_sampens) <- bplapply(sampens, \(x) x$file, BPPARAM = param)

# hist(apply(med_sampens, 1, function(x) sum(is.na(x))))

# remove windows with more than 50 missing values
# med_sampens <- med_sampens[apply(med_sampens, 1, function(x) sum(is.na(x))) < 50,]
## dim(na.omit(med_sampens))
## rather all nas go out

med_sampens <- na.omit(med_sampens)

column_ha <- HeatmapAnnotation(
  patient = gsub(regex, "\\2", basename(colnames(med_sampens))),
  location = gsub(regex, "\\3", basename(colnames(med_sampens)))
)

row_ha <- rowAnnotation(tile_annotation = as.matrix(data.frame(
  pmd = annot[rownames(med_sampens), "pmds_pmd"],
  hmd = annot[rownames(med_sampens), "hmds_pmd"],
  H3K27me3 = annot[rownames(med_sampens), "H3K27me3_chip"],
  H3K9me3 = annot[rownames(med_sampens), "H3K9me3_chip"],
  H3K4me3 = annot[rownames(med_sampens), "H3K4me3_chip"],
  laminb1 = annot[rownames(med_sampens), "laminb1_lad"],
  X8_Quiescent = annot[rownames(med_sampens), "8_Quiescent_hmm"]
)))

Heatmap(med_sampens,
  name = "med sampens",
  top_annotation = column_ha,
  right_annotation = row_ha,
  show_row_names = FALSE,
  column_labels = gsub(".det.out", "", basename(colnames(med_sampens)))
)
```

## Plus Shannons tile margin

Let's add the shannons, out of curiosity

```{r, fig.width = 15, fig.height = 10, eval = TRUE}
shannons_wide <- as.data.frame(pivot_wider(shannons,
  id_cols = "window",
  names_from = c("patient", "location"),
  values_from = "shannon"
))

rownames(shannons_wide) <- shannons_wide$window
shannons_wide <- shannons_wide[, grep(
  "window", colnames(shannons_wide),
  invert = TRUE
)]

## clust samples by shannon; that's to order the cols for the lefthand annot heatmap to the main heatmap

tmp <- t(as.matrix(shannons_wide)[rownames(med_sampens), ])
tmp.hc <- hclust(dist(tmp))

row_shannons <- rowAnnotation(
  shannons = as.matrix(shannons_wide)[rownames(med_sampens), tmp.hc$order],
  width = ncol(med_sampens) * unit(3, "mm")
)

Heatmap(med_sampens,
  name = "med sampens",
  top_annotation = column_ha,
  right_annotation = row_ha,
  left_annotation = row_shannons,
  show_row_names = FALSE,
  column_labels = gsub(".det.out.gz", "", basename(colnames(med_sampens))),
  width = ncol(med_sampens) * unit(9, "mm")
)
```

## Range sampens

If Shannon is high we're interested in knowing the range of sampEns.

```{r, fig.width = 15, fig.height = 10}
range_sampens <- as.matrix(
  do.call(cbind.data.frame, lapply(sampens, \(x) x$range))
)
colnames(range_sampens) <- lapply(sampens, \(x) x$file)

rownames(range_sampens) <- paste0("w", seq_len(nrow(range_sampens)))
range_sampens[!is.finite(range_sampens)] <- NA

range_sampens <- na.omit(range_sampens)

Heatmap(range_sampens,
  name = "range sampens",
  top_annotation = column_ha,
  right_annotation = row_ha,
  left_annotation = row_shannons,
  show_row_names = FALSE,
  column_labels = gsub(".det.out.gz", "", basename(colnames(range_sampens))),
  width = ncol(range_sampens) * unit(9, "mm")
)
```


## Rather cluster the Shannon's and add sampEns as tile margins

What if clustering the shannon's instead, and annotating the avg sampens?

```{r, fig.width = 18, fig.height = 10, eval = TRUE}
curr_shannons <- as.matrix(shannons_wide)[rownames(med_sampens), ]

col_ha <- HeatmapAnnotation(
  patient = gsub("(.*)_(.*)", "\\1", basename(colnames(curr_shannons))),
  location = gsub("(.*)_(.*)", "\\2", basename(colnames(curr_shannons)))
)

colnames(med_sampens) <- gsub(
  ".det.out.gz", "", basename(colnames(med_sampens))
)
row_med_sampens <- rowAnnotation(med_sampens = med_sampens)

Heatmap(curr_shannons,
  name = "shannons",
  top_annotation = col_ha,
  left_annotation = row_med_sampens,
  right_annotation = row_ha,
  show_row_names = FALSE
)
```

# Differential (sample) entropy / limma {.tabset .tabset-pills}

Just ~ patient + location

## Only sampen, no methylation correction

```{r, fig.width = 3, fig.height = 3}
sampen_fd <- do.call(cbind, lapply(sampens, \(x) x$sampen))

meta <- data.frame(
  colname = colnames(sampen_fd),
  patient = sapply(strsplit(colnames(sampen_fd), "_"), function(x) x[3]),
  location = substr(
    sapply(strsplit(colnames(sampen_fd), "_"), function(x) x[4]), 1, 2
  )
)

meta$location <- relevel(factor(meta$location), ref = "NC")

design <- model.matrix(~ meta$patient + meta$location)
fit_sampen <- lmFit(sampen_fd, design)
fit_sampen <- eBayes(fit_sampen)

hist(fit_sampen$p.value)

tt_sampen <- topTable(
  fit_sampen,
  coef = "meta$locationPT", n = Inf, sort.by = "none"
)

table(tt_sampen$adj.P.Val < 0.05)
```


```{r with_limma_0, fig.width = 18, fig.height = 10}
tt_sampen <- tt_sampen[rownames(med_sampens), ]
signif_sampen <- ifelse(tt_sampen$adj.P.Val < 0.05, yes = 1, no = 0)

row_tt_sampen <- rowAnnotation(PT_de_sampen = signif_sampen)

Heatmap(med_sampens,
  name = "med sampens",
  top_annotation = column_ha,
  right_annotation = row_ha,
  left_annotation = row_tt_sampen,
  show_row_names = FALSE,
  column_labels = gsub(".det.out", "", basename(colnames(med_sampens))),
  width = ncol(med_sampens) * unit(9, "mm")
)
```


## Only methylation

correct for diffs in avg meth; or perhaps test separately and overlap the two sets


```{r}
filepaths <- list.files(
  snakemake@params[["output_path"]],
  pattern = paste0(
    snakemake@wildcards[["win_size"]], "_(.*)\\.meth\\.out\\.gz$"
  ), full.names = TRUE
)

regex <- "(.*)_(.*)_(.*).meth.out.gz"
process_meth_reports <- function(filepath) {
  filename <- basename(filepath)
  patient <- gsub(regex, "\\2", filename)
  location <- gsub(regex, "\\3", filename)

  dt <- read_tsv(
    filepath,
    na = "-1", n_max = NROWS,
    show_col_types = FALSE
  )

  ## meths
  cols <- grep("singleC", colnames(dt), value = TRUE)
  rows <- paste0("w", seq_len(nrow(dt)))

  se <- as(as.matrix(dt[, cols]), "dgCMatrix")

  dimnames(se) <- list(rows, cols)

  return(list(meth = list(
    file = filepath,
    patient = patient,
    location = location,
    meth = se
  )))
}

meths <- bplapply(filepaths, \(x) process_meth_reports(x)$meth, BPPARAM = param)


meths_fd <- do.call(cbind, lapply(meths, \(x) x$meth))

design <- model.matrix(~ meta$patient + meta$location) # same design as above
fit_meth <- lmFit(meths_fd, design)
fit_meth <- eBayes(fit_meth)
```


```{r, fig.width = 3, fig.height = 3}
hist(fit_meth$p.value)

tt_meth <- topTable(
  fit_meth,
  coef = "meta$locationPT", n = Inf, sort.by = "none"
)

table(tt_meth$adj.P.Val < 0.05)
```


```{r with_limma_1, fig.width = 18, fig.height = 10}
tt_meth <- tt_meth[rownames(med_sampens), ]
signif_meth <- ifelse(tt_meth$adj.P.Val < 0.05, yes = 1, no = 0)

table(signif_meth %in% signif_sampen)

row_tt <- rowAnnotation(limma = as.matrix(data.frame(
  PT_de_meth = signif_meth,
  PT_de_sampen = signif_sampen
)))

Heatmap(med_sampens,
  name = "med sampens",
  top_annotation = column_ha,
  right_annotation = row_ha,
  left_annotation = row_tt,
  show_row_names = FALSE,
  column_labels = gsub(".det.out", "", basename(colnames(med_sampens))),
  width = ncol(med_sampens) * unit(9, "mm")
)
```

## sampen with methylation correction

Doing 

## GO

add 'genes' as a layer to the window annotation and store the id for gene ontology/geneset enrichment (on limma diff entropic regions)


```{r}
sessionInfo()
knitr::knit_exit()
```
