#!/usr/bin/env snakemake -s
##
## Runs yamet
##
## See https://github.com/emsonder/MethQuant-analysis/blob/cleanup/01_ecker_brain_atlas_2021/01_get_regions.sh
##   for further annotations
##
## Started 2nd Dec 2024

import os.path as op
import pandas as pd

include: op.join('rules', 'ecker.smk')
include: op.join('rules', 'mm10_annotations.smk')
include: op.join('rules', 'crc.smk')
include: op.join('rules', 'feature_simulations.smk')

## the shuffling is to have as many permutations as len(seed) of each of the annotations, to build
##   multiple entropy background distributions
rule all:
    input:
        op.join('ecker_data', 'downloaded_ecker.flag'), ## this is to download Ecker's cytosine reports
        op.join('ecker_data', 'harmonized_ecker_metadata.tsv.gz'), ## this to download Ecker's metadata
        op.join('annotation', 'mm10', 'done.flag'), ## this to download regions for Ecker's
        op.join('crc_data', 'downloaded_crc.flag'), # this to download CRC cytosine reports
        expand(op.join('annotation', 'shuffled', '{assembly}', '{seed}', '{annotation}.bed.gz'),
               seed = [1,2],
               assembly = 'mm10',
               annotation = ['transcripts', 'promoters']), ## to get a random background features
        op.join('feature_simulations', 'output', 'yamet_detailed.out') ## feature simulations

## yamet is compiled by install_yamet and exported for each shell directive
shell.prefix("export PATH=../method/build:$PATH;")

rule install_yamet:
    conda:
        "envs/yamet.yml" # for cmake mainly
    output:
        op.join("..", "method", "build", "yamet")
    shell:
        """
        bash ../method/build.sh
        """
        
        
rule shuffle_annotations:
    conda:
        op.join("envs", "yamet.yml")
    input:
        bed = op.join('annotation', '{assembly}', '{annotation}.bed.gz'),
        genome = op.join('annotation', '{assembly}','genome.sizes')
    output:
        op.join('annotation', 'shuffled','{assembly}', '{seed}', '{annotation}.bed.gz')
    params:
        path = op.join('annotation', 'shuffled','{assembly}', '{seed}')
    shell:
        """
        mkdir -p {params.path}
        zcat {input.bed} | \
            bedtools shuffle -i - -g {input.genome} -seed {wildcards.seed} | \
            gzip -c > {output}
        """

# ## inputs from ecker.smk
# ## how do we run yamet? in batches of cells? how to automate this so the shuffled backgrounds
# ##   are coupled as well?
# ##  we can use `slice_eckers_metadata(column, value)` to generate the cell inputs
# rule run_yamet_on_ecker:
#     conda:
#         op.join("envs", "yamet.yml")
#     input:
#         bed = op.join('annotation', 'mm10', '{annotation}.bed.gz'),
#         genome = op.join('annotation', 'mm10','genome.sizes')
#     output:
#         detailed = op.join('yamet', '{annotation}', '{cells}')
#     message:
#         """
#         echo running yamet on {input.bed} and {input.annotation}
#         """
#     shell:
#         """
#         echo 'not implemented but slice_eckers_metadata(column, value) is key'
#         """


# ## data download - pending stuff

## inputs from feature_simulations.smk
rule run_yamet_simulated_features:
    conda:
        op.join("envs", "yamet.yml")
    input:
        yamet = op.join("..", "method", "build", "yamet"),
        cell = op.join('feature_simulations', 'output', 'simulations.tsv'),
        reference = op.join('feature_simulations', 'output', 'reference.tsv'),
        regions = op.join('feature_simulations', 'output', 'regions.bed')
    output:
        out = op.join('feature_simulations', 'ouput', 'yamet_summarized.out'),
        detailed_output = op.join('feature_simulations', 'output', 'yamet_detailed.out')
    threads:
        4
    log:
        op.join('feature_simulations', 'run.log')
    shell:
        """
        yamet --cell {input.cell} \
              --reference {input.reference} \
              --intervals {input.regions} \
              --det-out {output.detailed_output} \
              --out {output.out} \
              --cores {threads} \
              --print-intervals &> {log}        
        """

# def download_scnmt_gastrulation():
#     return NULL

# ## perhaps lines and sines separately?
# def download_mm10_repeats(assembly = 'mm10'):
#     return NULL

