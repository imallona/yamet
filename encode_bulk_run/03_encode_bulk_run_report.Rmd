---
title: "CpG entropies scoring"
params:
  seed: 1
author: "Izaskun Mallona (Mark Robinson, Tuncay Baubec labs)"
output:
  html_document:
    keep_md: true
    toc: true
    toc_float: true
    toc_depth: 4

---

```{r libraries, include=FALSE, cache = FALSE}
library('latex2exp')
library(entropy)
library(cramer)
library(Cairo)
library(knitr)
library(ggplot2)
library(RColorBrewer)
library(gridExtra)
library(data.table)
suppressPackageStartupMessages(library(dplyr))
library(pheatmap)
library(ggExtra)
library(tidyverse)
library(viridis)



opts_chunk$set(fig.width = 12,
               fig.height = 12,
               cache = TRUE,
               include = TRUE,
               cache.lazy = FALSE,
               warning = TRUE,
               message = TRUE)


options(bitmapType='cairo')
getOption('bitmapType')


```

```{r functions}

ac  <- function(col, alpha=1){
  apply(sapply(col, col2rgb)/255, 2, 
                     function(x) 
                       rgb(x[1], x[2], x[3], alpha=alpha))  
}

beta2m <- function(beta) {
    m <- log2(beta/(1 - beta))
    m
}

```

# Data load

```{r samples_dict}
samples_dict <- read.table(text ='id,exp_url,bam_url,assembly,description,replicate,end
ENCFF112TXF,https://www.encodeproject.org/experiments/ENCSR888FON/,https://www.encodeproject.org/files/ENCFF112TXF/@@download/ENCFF112TXF.bam,GRCh38,IMR90,1,single
ENCFF957OIM,https://www.encodeproject.org/experiments/ENCSR881XOU/,https://www.encodeproject.org/files/ENCFF957OIM/@@download/ENCFF957OIM.bam,GRCh38,HepG2,1,paired
ENCFF572KNK,https://www.encodeproject.org/experiments/ENCSR881XOU/,https://www.encodeproject.org/files/ENCFF572KNK/@@download/ENCFF572KNK.bam,GRCh38,HepG2,2,paired
ENCFF193RVP,https://www.encodeproject.org/experiments/ENCSR550RTN/,https://www.encodeproject.org/files/ENCFF193RVP/@@download/ENCFF193RVP.bam,GRCh38,HeLa-S3,1,paired
ENCFF845VFH,https://www.encodeproject.org/experiments/ENCSR550RTN/,https://www.encodeproject.org/files/ENCFF845VFH/@@download/ENCFF845VFH.bam,GRCh38,HeLa-S3,2,paired
ENCFF079RGH,https://www.encodeproject.org/experiments/ENCSR440MLE/,https://www.encodeproject.org/files/ENCFF079RGH/@@download/ENCFF079RGH.bam,GRCh38,GM23248,1,paired
ENCFF119ELB,https://www.encodeproject.org/experiments/ENCSR440MLE/,https://www.encodeproject.org/files/ENCFF119ELB/@@download/ENCFF119ELB.bam,GRCh38,GM23248,2,paired/',
sep = ',', header = TRUE, stringsAsFactors = TRUE)

rownames(samples_dict) <- samples_dict$id
```

```{r}
colored <- list.files(path = 'encode_bulk', pattern = '*colored.bed', recursive = TRUE)

d <- list(entropy = list(),
          meth = list())

d$entropy_fns <- grep('entropy', colored, value = TRUE)
d$meth_fns <- grep('meth', colored, value = TRUE)

for (item in d$entropy_fns) {
    tryCatch({
        ssample <- dirname(item)
        foo <- read.table(file.path('encode_bulk', item), header = FALSE)
        if (nrow(foo) > 0)
            d$entropy[[ssample]] <- foo
    }, error = function(x) print(x))
}

for (item in d$meth_fns) {
    tryCatch({
        ssample <- dirname(item)
        foo  <- read.table(file.path('encode_bulk', item), header = FALSE)
        if (nrow(foo) > 0)
            d$meth[[ssample]] <- foo
    }, error = function(x) print(x))
}



```

```{r}
hmm_colors <- read.table(text = "Art
Ctcf
CtcfO
DnaseD
DnaseU
Elon
ElonW
Enh
EnhF
EnhW
EnhWF
FaireW
Gen3'
Gen5'
H4K20
Low
Pol2
PromF
PromP
Quies
Repr
ReprD
ReprW
Tss
TssF", stringsAsFactors = FALSE)$V1

```

# Merging meth and entropies

```{r merging}
d$merged <- list()
for (ssample in names(d$entropy)) {
    if (nrow(d$entropy[[ssample]]) > 0) {
        d$merged[[ssample]] <- data.frame(pos1 = d$entropy[[ssample]]$V2,
                                          pos2 =  d$entropy[[ssample]]$V3,
                                          name = d$entropy[[ssample]]$V4,
                                          entropy = d$entropy[[ssample]]$V5,
                                          strand = d$entropy[[ssample]]$V6,
                                          hmm = d$entropy[[ssample]]$V7,
                                          beta = d$meth[[ssample]]$V5)

        d$merged[[ssample]]$beta <- d$merged[[ssample]]$beta/1000
        
        ## sapply(d$merged[[ssample]]$name, function(x) strsplit(x, ':'))
        tmp <-  strsplit(as.character(d$merged[[ssample]]$name), ';')

        d$merged[[ssample]]$MM <- as.numeric(gsub('MM', '', sapply(tmp, function(x) return(x[1]))))
        d$merged[[ssample]]$MU <- as.numeric(gsub('MU', '', sapply(tmp, function(x) return(x[2]))))
        d$merged[[ssample]]$UM <- as.numeric(gsub('UM', '', sapply(tmp, function(x) return(x[3]))))
        d$merged[[ssample]]$UU <- as.numeric(gsub('UU', '', sapply(tmp, function(x) return(x[4]))))

        d$merged[[ssample]]$m <- beta2m(d$merged[[ssample]]$beta)
        d$merged[[ssample]]$distance <- d$merged[[ssample]]$pos2 - d$merged[[ssample]]$pos1
        d$merged[[ssample]]$log10dist <- log10(d$merged[[ssample]]$distance)
        d$merged[[ssample]]$coverage <- d$merged[[ssample]]$MM +
            d$merged[[ssample]]$MU +
            d$merged[[ssample]]$UM +
            d$merged[[ssample]]$UU
        
        rm(tmp)
    }
}

d <- d$merged


```

# Modeling entropies constraints

Estimating the unmethylated and methylated tuples according to the beta value and coverage

```{r}

for (item in names(d)) {

    d[[item]]$pU <- (d[[item]]$cov - (d[[item]]$cov * d[[item]]$beta))/d[[item]]$cov
    d[[item]]$pM <- 1 - d[[item]]$pU
}

```

(Better speed up this)

```{r}

for (item in names(d)) {
    d[[item]]$max_entropy <- apply(data.frame(pUU = d[[item]]$pU^2,
                                              pUM = d[[item]]$pU * d[[item]]$pM,
                                              pMU = d[[item]]$pU * d[[item]]$pM,
                                              pMM = d[[item]]$pM^2),
                                   1, entropy)


    d[[item]]$min_entropy_full <- apply(data.frame(pUU = d[[item]]$pU,
                                                   pUM = 0,
                                                   pMU = 0,
                                                   pMM = d[[item]]$pM),
                                        1, entropy)


    d[[item]]$min_entropy_beta <- apply(data.frame(pUU = 0,
                                                   pUM = abs(d[[item]]$pM - d[[item]]$pU)/2 ,
                                                   pMU =  0,
                                                   pMM = d[[item]]$pM),
                                        1, entropy)

    d[[item]]$min_entropy_beta[d[[item]]$beta >= 0.5] <- apply(data.frame(
        pU = 0,
        pUM = abs(d[[item]][d[[item]]$beta >= 0.5,]$pM - d[[item]][d[[item]]$beta >= 0.5,]$pU)/2 ,
        pMU =  0,
        pMM = d[[item]][d[[item]]$beta >= 0.5,]$pU),
        1,
        entropy)


    d[[item]]$lower_bound <- apply(d[[item]][,c('min_entropy_full', 'min_entropy_beta')], 1, min)
}
```

```{r plotsbounds}

for (item in names(d)) {
    
    par(cex.axis = 1.4,
        cex.lab = 1.4,
        cex.main = 1.4,
        cex.sub = 1.4,
        pty = "s",
        mar=c(5.1,4.1,4.1,2.1),
        oma = c(4, 4, 1, 1))

    plot(d[[item]]$beta, d[[item]]$entropy, pch = 19, col = ac('black', 0.5),
         xlab = sprintf('%s %s methylation (beta value)', samples_dict[item, 'description'],
                        item),
         ylab = "Shannon's entropy (H)" )
    lines(d[[item]]$beta, d[[item]]$max_entropy, col = 'darkred', type = 'p', pch = 4, cex = 1)
    lines(d[[item]]$beta, d[[item]]$lower_bound, col = 'darkblue', type = 'p', pch = 4, cex = 1)

    legend('topright',
           col = c('black', 'darkred', 'darkblue'),
           pch = c(19, 4, 4),
           legend = c('observation', TeX('$H_{max}$'), TeX('$H_{min}$')))

}
```

Standardizing entropy values to the min and max theoretical entropies

```{r}
for (item in names(d)) {
    
    d[[item]]$standardized_entropy <- (d[[item]]$entropy - d[[item]]$lower_bound) / (d[[item]]$max_entropy - d[[item]]$lower_bound)

    summary(d[[item]]$standardized_entropy)

    d[[item]]$standardized_entropy[is.na(d[[item]]$standardized_entropy)] <- 0

    par(cex.axis = 1.4,
        cex.lab = 1.4,
        cex.main = 1.4,
        cex.sub = 1.4,
        pty = "s",
        mar=c(5.1,4.1,4.1,2.1),
        oma = c(4, 4, 1, 1))

    plot(d[[item]]$beta, d[[item]]$standardized_entropy, pch = 19, col = ac('black', 0.5),
         xlab = sprintf('%s %s methylation (beta value)', samples_dict[item, 'description'],
                        item),
         ylab = "standardized entropy (stdH)" )

}
```

```{r marginals}

for (item in names(d)) {
    print(sprintf('%s %s', samples_dict[item, 'description'], item))
    p=ggplot(d[[item]], aes(x=beta, y=standardized_entropy, color=entropy)) +
        geom_point() +
        theme(legend.position ='top') + xlab(sprintf('%s methylation (beta)', item)) +
        ylab('standardized entropy (stdH)')
    
                                        # marginal density
    p2 <- ggMarginal(p, type="histogram")

    p <- ggplot(d[[item]], aes(x=entropy, y=standardized_entropy, color=beta)) +
        geom_point() +
        theme(legend.position ='top')  + xlab('entropy (H)') +
        ylab('standardized entropy (stdH)')

    p3 <- ggMarginal(p, type="histogram")

    p4 <-grid.arrange(p2, p3, ncol=2)
    p4
    ggsave(sprintf('%s_standardized_vs_entropy.png', item), plot = p4, width = 10, height=5)
}
```

```{r coverage_vs_entropy}
for (item in names(d)) {
    print(item)
    curr <- d[[item]]
    
    targets <- c('coverage',
             'distance',
             'beta',
             'entropy')

    par(cex.axis = 1.4,
        cex.lab = 1.4,
        cex.main = 1.4,
        cex.sub = 1.4,
        pty = "s",
        mar=c(5.1,4.1,4.1,2.1),
        oma = c(1, 0, 0, 0))

    plot(curr[,targets], pch = 20,
         col = ac('black', 0.1),
         main = item)
    
}


```


```{r recycling}

for (item in names(d)) {
    print(sprintf('%s %s', samples_dict[item, 'description'], item))

    rf <- colorRampPalette(rev(brewer.pal(11,'Spectral')))
    r <- rf(32)

    curr <- d[[item]]

    for (color in hmm_colors) {
        curr[,color] <- NA
        curr[,color] <- grepl(color, as.character(curr$hmm))
    }


    
    curr$in_boundary <- apply(curr[,as.character(hmm_colors)], 1, function(x) sum(x) > 1)
    table(curr$in_boundary)

    d[[item]] <- curr

    ## now subsetting to those not in boundary
    outer <- curr[!curr$in_boundary,]
  

    for (hmm_color in hmm_colors) {
        curr <- outer[outer[,hmm_color],]
        
        p <- ggplot(curr[,c('beta', 'entropy')], aes(beta, entropy))

        ## h3 <- p + stat_bin2d(bins=25) + scale_fill_gradientn(colours=r) + xlim(-0.1, 1.1) +
        ##     ylim(-0.1, entropy_max + 0.1) + ggtitle(hmm_color)
        
        h3 <- p + stat_bin2d(bins=25) + scale_fill_gradientn(colours=r) + xlim(-0.1, 1.1) +
            ylim(-0.1,1.5) + ggtitle(hmm_color) + theme(text = element_text(size=20)) +
            xlab(sprintf('DNA methylation (beta)', item)) + ylab("Shannon's entropy (H)")
        

        p <- ggplot(curr[,c('beta', 'standardized_entropy')], aes(beta, standardized_entropy))
        h4 <- p + stat_bin2d(bins=25) + scale_fill_gradientn(colours=r) + xlim(-0.1, 1.1) +
            ylim(-0.1,1) + ggtitle(hmm_color) + theme(text = element_text(size=20)) +
            xlab('DNA methylation (beta)') + ylab("Standardized entropy (stdH)")
        
        grid.arrange(h3, h4, ncol=2)
        
        
        
    }
}

```

```{r quantiles, fig.width = 7, fig.height = 7}

for (item in names(d)) {
    print(sprintf('%s %s', samples_dict[item, 'description'], item))

    curr <- d[[item]]

    curr$unmethylated <- curr$beta < 0.2
    curr$methylated <- curr$beta >= 0.8
    curr$zero_entropy <- curr$entropy == 0


    non_boundary <- list(median = tapply(curr[!curr$in_boundary, 'entropy'],
                                         as.factor(as.character(curr[!curr$in_boundary, 'hmm'])),
                                         function(x) quantile(x, probs = 0.5)),
                         lower = tapply(curr[!curr$in_boundary, 'entropy'],
                                        as.factor(as.character(curr[!curr$in_boundary, 'hmm'])),
                                        function(x) quantile(x, probs = 0.25)),
                         upper = tapply(curr[!curr$in_boundary, 'entropy'],
                                        as.factor(as.character(curr[!curr$in_boundary, 'hmm'])),
                                        function(x) quantile(x, probs = 0.755)))



    ## sort by median, plot
    sorted <- names(sort(non_boundary$median))

    par(cex.axis = 1.8,
        cex.lab = 1.8,
        cex.main = 1.8,
        cex.sub = 1.8,
        pty = "s",
        mar=c(5.1,4.1,4.1,2.1),
        oma = c(1.2, 0, 0, 0),
        xpd = TRUE)

    plot(non_boundary$lower[sorted], pch = 20,
         ylim = c(0, max(unlist(non_boundary))),
         ylab = "Shannon's entropy (H)" ,
         xaxt = "n",
         xlab = "",
         main = '')

    points(non_boundary$median[sorted], pch = 20, col = 'red')
    points(non_boundary$upper[sorted], pch = 20)

    segments(y0 = non_boundary$lower[sorted],
             y1 = non_boundary$upper[sorted],
             x0 = 1:length(non_boundary$lower),
             x1 = 1:length(non_boundary$lower))

    legend('topright', col = c('black', 'red', 'black'), pch = 20, c('3Q', 'median', '1Q'),
           inset=c(-0.25,0))

    axis(1, at = 1:length(sorted), labels = sorted, las = 2)
}

```

```{r quantilesmethylation, fig.width = 7, fig.height = 7}
for (item in names(d)) {
    print(sprintf('%s %s', samples_dict[item, 'description'], item))

    curr <- d[[item]]
    non_boundary <- list(median = tapply(curr[!curr$in_boundary, 'beta'],
                                         as.factor(as.character(curr[!curr$in_boundary, 'hmm'])),
                                         function(x) quantile(x, probs = 0.5)),
                         lower = tapply(curr[!curr$in_boundary, 'beta'],
                                        as.factor(as.character(curr[!curr$in_boundary, 'hmm'])),
                                        function(x) quantile(x, probs = 0.25)),
                         upper = tapply(curr[!curr$in_boundary, 'beta'],
                                        as.factor(as.character(curr[!curr$in_boundary, 'hmm'])),
                                        function(x) quantile(x, probs = 0.755)))


    par(cex.axis = 1.8,
        cex.lab = 1.8,
        cex.main = 1.8,
        cex.sub = 1.8,
        pty = "s",
        mar=c(5.1,4.1,4.1,2.1),
        oma = c(1.2, 0, 0, 0))

    plot(non_boundary$lower[sorted], pch = 20,
         ylim = c(0, max(unlist(non_boundary))),
         ylab = 'methylation (beta)',
         xaxt = "n",
         xlab = "",
         main = '')

    points(non_boundary$median[sorted], pch = 20, col = 'red')
    points(non_boundary$upper[sorted], pch = 20)
    segments(y0 = non_boundary$lower[sorted],
             y1 = non_boundary$upper[sorted],
             x0 = 1:length(non_boundary$lower),
             x1 = 1:length(non_boundary$lower))

    axis(1, at = 1:length(sorted), labels = sorted, las = 2)
}

```


```{r quantilessratified}

for (item in names(d)) {
    print(sprintf('%s %s', samples_dict[item, 'description'], item))
 
    curr <- d[[item]]
    
    curr <- curr[!curr$in_boundary,]
    curr$hmm <- as.factor(as.character(curr$hmm))
    ## categorical methylation status
    curr$meth_cat <- 'mid'
    curr$meth_cat[curr$unmethylated] <- 'low'
    curr$meth_cat[curr$methylated] <- 'high'
    curr$meth_cat <- factor(curr$meth_cat, levels = c('low', 'mid', 'high'))

    ## ggplot(curr, aes(factor(hmm), entropy, fill = meth_cat)) +
    ##   geom_bar(stat="identity", position = "dodge") +
    ##   scale_fill_brewer(palette = "Set1")



    h <- ggplot(aes(y = entropy, x = hmm, fill = meth_cat), data = curr) +
        geom_boxplot(outlier.alpha = 0.5, color = 'darkblue') +
        scale_fill_manual(values=c("gray90", "gray60", "gray30")) +
        ylab("Shannon's entropy (H)") +
        xlab('chromatin state (chromHMM)') +
        theme_bw() +
        theme(text = element_text(size = 15),
              axis.text.x = element_text(angle = 90, hjust = 1))

    h
}

```

## Standardized


```{r quantilesstd, fig.width = 7, fig.height = 7}

for (item in names(d)) {
    print(sprintf('%s %s', samples_dict[item, 'description'], item))

    curr <- d[[item]]
    
    curr$unmethylated <- curr$beta < 0.2
    curr$methylated <- curr$beta >= 0.8
    curr$zero_standardized_entropy <- curr$standardized_entropy == 0


    non_boundary <- list(median = tapply(curr[!curr$in_boundary, 'standardized_entropy'],
                                         as.factor(as.character(curr[!curr$in_boundary, 'hmm'])),
                                         function(x) quantile(x, probs = 0.5)),
                         lower = tapply(curr[!curr$in_boundary, 'standardized_entropy'],
                                        as.factor(as.character(curr[!curr$in_boundary, 'hmm'])),
                                        function(x) quantile(x, probs = 0.25)),
                         upper = tapply(curr[!curr$in_boundary, 'standardized_entropy'],
                                        as.factor(as.character(curr[!curr$in_boundary, 'hmm'])),
                                        function(x) quantile(x, probs = 0.755)))



    ## sort by median, plot
    sorted <- names(sort(non_boundary$median))

    par(cex.axis = 1.8,
        cex.lab = 1.8,
        cex.main = 1.8,
        cex.sub = 1.8,
        pty = "s",
        mar=c(5.1,4.1,4.1,2.1),
        oma = c(1.2, 0, 0, 0),
        xpd = TRUE)

    plot(non_boundary$lower[sorted], pch = 20,
         ylim = c(0, max(unlist(non_boundary))),
         ylab = "Shannon's standardized_entropy (stdH)" ,
         xaxt = "n",
         xlab = "",
         main = '')

    points(non_boundary$median[sorted], pch = 20, col = 'red')
    points(non_boundary$upper[sorted], pch = 20)

    segments(y0 = non_boundary$lower[sorted],
             y1 = non_boundary$upper[sorted],
             x0 = 1:length(non_boundary$lower),
             x1 = 1:length(non_boundary$lower))

    legend('topright', col = c('black', 'red', 'black'), pch = 20, c('3Q', 'median', '1Q'),
           inset=c(-0.25,0))

    axis(1, at = 1:length(sorted), labels = sorted, las = 2)
}
```

```{r quantilesmethylationstd, fig.width = 7, fig.height = 7}
for (item in names(d)) {
    print(sprintf('%s %s', samples_dict[item, 'description'], item))

    curr <- d[[item]]
    
    non_boundary <- list(median = tapply(curr[!curr$in_boundary, 'beta'],
                                         as.factor(as.character(curr[!curr$in_boundary, 'hmm'])),
                                         function(x) quantile(x, probs = 0.5)),
                         lower = tapply(curr[!curr$in_boundary, 'beta'],
                                        as.factor(as.character(curr[!curr$in_boundary, 'hmm'])),
                                        function(x) quantile(x, probs = 0.25)),
                         upper = tapply(curr[!curr$in_boundary, 'beta'],
                                        as.factor(as.character(curr[!curr$in_boundary, 'hmm'])),
                                        function(x) quantile(x, probs = 0.755)))


    par(cex.axis = 1.8,
        cex.lab = 1.8,
        cex.main = 1.8,
        cex.sub = 1.8,
        pty = "s",
        mar=c(5.1,4.1,4.1,2.1),
        oma = c(1.2, 0, 0, 0))

    plot(non_boundary$lower[sorted], pch = 20,
         ylim = c(0, max(unlist(non_boundary))),
         ylab = 'methylation (beta)',
         xaxt = "n",
         xlab = "",
         main = '')

    points(non_boundary$median[sorted], pch = 20, col = 'red')
    points(non_boundary$upper[sorted], pch = 20)
    segments(y0 = non_boundary$lower[sorted],
             y1 = non_boundary$upper[sorted],
             x0 = 1:length(non_boundary$lower),
             x1 = 1:length(non_boundary$lower))

    axis(1, at = 1:length(sorted), labels = sorted, las = 2)

}
```


```{r quantilessratifiedstd}
for (item in names(d)){
    print(sprintf('%s %s', samples_dict[item, 'description'], item))

    curr <- d[[item]]
    
    curr <- curr[!curr$in_boundary,]
    curr$hmm <- as.factor(as.character(curr$hmm))
    ## categorical methylation status
    curr$meth_cat <- 'mid'
    curr$meth_cat[curr$unmethylated] <- 'low'
    curr$meth_cat[curr$methylated] <- 'high'
    curr$meth_cat <- factor(curr$meth_cat, levels = c('low', 'mid', 'high'))

    ## ggplot(curr, aes(factor(hmm), standardized_entropy, fill = meth_cat)) +
    ##   geom_bar(stat="identity", position = "dodge") +
    ##   scale_fill_brewer(palette = "Set1")



    h <- ggplot(aes(y = standardized_entropy, x = hmm, fill = meth_cat), data = curr) +
        geom_boxplot(outlier.alpha = 0.5, color = 'darkblue') +
        scale_fill_manual(values=c("gray90", "gray60", "gray30")) +
        ylab("Shannon's standardized_entropy (stdH)") +
        xlab('chromatin state (chromHMM)') +
        theme_bw() +
        theme(text = element_text(size = 15),
              axis.text.x = element_text(angle = 90, hjust = 1))

    h
}
```


<!-- ## Other plots -->

<!-- ```{r} -->

<!-- targets <- c('coverage', -->
<!--              ## 'distance', -->
<!--              'beta', -->
<!--              'entropy', -->
<!--              'standardized_entropy') -->
<!-- summary(d[,targets]) -->

<!-- plot(d[,targets]) -->


<!-- ``` -->

<!-- ```{r plotbycolors, eval = FALSE} -->



<!-- for (hmm in hmm_colors) { -->
<!--     curr <- d[d[,hmm],] -->

<!--     ## downsampling for plotting purposes -->
<!--     set.seed(1) -->
<!--     curr <- curr[sample(x=nrow(curr), 1e3),] -->
    
<!--     targets <- c('coverage', -->
<!--                  ## 'distance', -->
<!--                  'beta', -->
<!--                  'entropy', -->
<!--                  'standardized_entropy') -->


<!--     plot(curr[,targets], main = hmm) -->

    
<!--     rm(curr) -->
<!-- } -->

<!-- ``` -->

<!-- # Cramer tests -->

<!-- ```{r cramer, eval = TRUE, cache = FALSE} -->
<!-- tests <- list() -->

<!-- short_hmm_colors <- c('Enh', 'Ctcf', 'Tss', 'PromP', 'PromF') -->
<!-- d$hmm <- as.character(d$hmm) -->
<!-- i <- 1 -->
<!-- while (i < length(short_hmm_colors)) { -->
<!--     j <- i + 1 -->
<!--     while (j <= length(short_hmm_colors)) { -->
<!--         cat('.') -->
<!--         ## caution, downsampling! -->
<!--         DOWNSAMPLING = 5e2 -->
<!--         ## stop() -->

       
<!--         first <- d[d$hmm == short_hmm_colors[i] & !d$in_boundary, c('beta', 'entropy')] -->
<!--         set.seed(1) -->
<!--         if (DOWNSAMPLING <= nrow(first)) -->
<!--             first <- as.matrix(first[sample(nrow(first), DOWNSAMPLING),]) -->

<!--         second <- d[d$hmm == short_hmm_colors[j] & !d$in_boundary, c('beta', 'entropy')] -->
<!--         set.seed(1) -->
<!--         if (DOWNSAMPLING <= nrow(second)) -->
<!--             second <- as.matrix(second[sample(nrow(second), DOWNSAMPLING),]) -->
              
<!--         foo <- cramer.test(first, -->
<!--                            second, -->
<!--                            sim = "eigenvalue") -->

<!--         tests[[paste(short_hmm_colors[i], short_hmm_colors[j], 'bivariate', 'entropy')]] <- c(short_hmm_colors[i], -->
<!--                                                                                   short_hmm_colors[j], -->
<!--                                                                                   'entropy', -->
<!--                                                                                   'bivariate', -->
<!--                                                                                   foo$p.value, -->
<!--                                                                                   foo$statistic) -->
<!--         rm(foo) -->




<!--         foo <- ks.test(first[,'entropy'], -->
<!--                        second[,'entropy']) -->
<!--         tests[[paste(short_hmm_colors[i], short_hmm_colors[j], 'univariate', 'entropy')]] <- c(short_hmm_colors[i], -->
<!--                                                                                    short_hmm_colors[j], -->
<!--                                                                                    'entropy', -->
<!--                                                                                    'univariate', -->
<!--                                                                                    foo$p.value, -->
<!--                                                                                    foo$statistic) -->
<!--         rm(foo) -->

        
<!--         first <- d[d$hmm == short_hmm_colors[i] & !d$in_boundary, -->
<!--                    c('beta', 'standardized_entropy')] -->
<!--         set.seed(1) -->
<!--         if (DOWNSAMPLING <= nrow(first)) -->
<!--             first <- as.matrix(first[sample(nrow(first), DOWNSAMPLING),]) -->

<!--         second <- d[d$hmm == short_hmm_colors[j] & !d$in_boundary, -->
<!--                     c('beta', 'standardized_entropy')] -->
<!--         set.seed(1) -->
<!--         if (DOWNSAMPLING <= nrow(second)) -->
<!--             second <- as.matrix(second[sample(nrow(second), DOWNSAMPLING),]) -->
              

<!--         foo <- cramer.test(first, -->
<!--                            second, -->
<!--                            sim = "eigenvalue") -->
        
<!--         tests[[paste(short_hmm_colors[i], short_hmm_colors[j], -->
<!--                      'bivariate', 'standardized_entropy')]] <- c(short_hmm_colors[i], -->
<!--                                                                  short_hmm_colors[j], -->
<!--                                                                  'standardized_entropy', -->
<!--                                                                  'bivariate', -->
<!--                                                                  foo$p.value, -->
<!--                                                                  foo$statistic) -->
   
<!--         foo <- ks.test(first[,'standardized_entropy'], -->
<!--                        second[,'standardized_entropy']) -->
        
<!--         tests[[paste(short_hmm_colors[i], short_hmm_colors[j], 'univariate', -->
<!--                      'standardized_entropy')]] <- c(short_hmm_colors[i], -->
<!--                                                     short_hmm_colors[j], -->
<!--                                                     'standardized_entropy', -->
<!--                                                     'univariate', -->
<!--                                                     foo$p.value, -->
<!--                                                     foo$statistic) -->
<!--         rm(foo) -->


<!--         ## control -->
<!--         foo <- ks.test(first[,'beta'], -->
<!--                        second[,'beta']) -->

<!--         tests[[paste(short_hmm_colors[i], short_hmm_colors[j], 'univariate', -->
<!--                      'beta')]] <- c(short_hmm_colors[i], -->
<!--                                     short_hmm_colors[j], -->
<!--                                     'beta', -->
<!--                                     'univariate', -->
<!--                                     foo$p.value, -->
<!--                                     foo$statistic) -->
<!--         rm(foo) -->
       
<!--         ## stop() -->
<!--         j <- j +1 -->

<!--     } -->
<!--     i <- i + 1 -->
<!-- } -->
<!-- ``` -->

<!-- ```{r agg, eval = TRUE, fig.width = 6, fig.height = 5, cache = FALSE} -->
<!-- agg <- do.call(rbind.data.frame, tests) -->
<!-- colnames(agg) <- c('hmm_1', 'hmm_2', 'variable', 'test', 'pval', 'stat') -->
<!-- agg$stat <- as.numeric(as.character(agg$stat)) -->
<!-- agg$pval <- as.numeric(as.character(agg$pval)) -->

<!-- DT::datatable(agg %>% as.data.frame() %>%  -->
<!--                 dplyr::mutate_if(is.numeric, funs(round(., 2))),  -->
<!--               extensions = c("Buttons", "FixedColumns"), -->
<!--               rownames = FALSE,  -->
<!--               options = list(dom = "Bfrtip", -->
<!--                              scrollX = TRUE,  -->
<!--                              fixedColumns = list(leftColumns = 1), -->
<!--                              buttons = c("csv", "excel"))) -->


<!-- ## print(agg) -->


<!-- ## p <- ggplot(data = agg, aes(as.factor(hmm_2),as.numeric(stat))) + geom_point() -->
<!-- ## p + facet_grid(variable ~ hmm_1 * test) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) -->


<!-- ## p <- ggplot(data = agg, aes(as.factor(paste0(hmm_1, '__' , hmm_2), -->
<!-- ##                                       color=ifelse(agg$pval <0.05, 'red', 'black')), -->
<!-- ##                             as.numeric(stat))) + geom_point() -->


<!-- ## p + facet_grid(variable ~ test) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) -->

<!-- ## p <- ggplot(data = agg, aes(as.factor(paste(hmm_1, hmm_2)),as.numeric(stat))) + geom_point() -->
<!-- ## p + facet_grid(variable ~ test) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) -->

<!-- agg$test <- as.character(agg$test) -->
<!-- agg$variable <- as.character(agg$variable) -->

<!-- agg$test[agg$test=='bivariate'] <- 'Cramer\n(bivariate)' -->
<!-- agg$test[agg$test=='univariate'] <- 'Kolmogorov-Smirnov\n(univariate)' -->

<!-- agg$variable[agg$variable=='standardized_entropy'] <- 'std_entropy' -->


<!-- p <- ggplot(data = agg, aes(as.factor(paste(hmm_1, '_', hmm_2)),as.numeric(stat), -->
<!--                             color = ifelse(pval >= 0.05, 'ns', 'p < 0.05'))) + -->
<!--     geom_point() + labs(colour = 'significance') + -->
<!--     ylab('test statistic (KS for univariate,\nCramer for bivariate)') + -->
<!--     xlab('Pairwise chromHMM comparison') -->
    
<!-- p + facet_grid(variable ~ test) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) -->


<!-- ``` -->

<!-- ```{r densities} -->
<!-- p <- ggplot(d[!d$in_boundary,], aes(x=entropy))+ -->
<!--                geom_density() + facet_grid(hmm ~ .) -->
            
<!-- p -->

<!-- p <- ggplot(d[!d$in_boundary,], aes(x=standardized_entropy))+ -->
<!--                geom_density() + facet_grid(hmm ~ .) -->
            
<!-- p -->

<!-- p <- ggplot(d[!d$in_boundary,], aes(x=beta))+ -->
<!--                geom_density() + facet_grid(hmm ~ .,) -->
            
<!-- p -->

<!-- ``` -->

```{r discretized,  fig.width = 10, fig.height=5}

for (item in names(d)) {
    print(sprintf('%s %s', samples_dict[item, 'description'], item))

    curr <- d[[item]]
    
    br = seq(0,1,by=0.1)

    ranges = paste(head(br,-1), br[-1], sep= " - ")


    heat <- as.data.frame(matrix(nrow = length(hmm_colors),
                                 ncol = length(ranges), data = NA),
                          col.names = paste0('beta_', ranges),
                          row.names = hmm_colors)

    colnames(heat) <- paste0('beta_', ranges)


    for (hmm in hmm_colors) {
        freq   = hist(curr[curr$hmm == hmm, 'beta'], breaks=br, include.lowest=TRUE, plot=FALSE)
        heat[hmm,] <- freq$counts
        
    }


    pheatmap(heat, cluster_cols = FALSE, main = 'instances')

    ## now average entropy or standardized entropy for each row

    ## as in https://stackoverflow.com/questions/51688222/two-types-of-variables-in-a-single-heatmap-using-r

    ## would require a long dataformat with
    ## hmm (rows), beta range (columns), value (the standardizes stuff(


    ## that is superdirty @todo fix
    curr$beta_categorical <- apply(curr, 1, function(x) {
        if (as.numeric(x['beta']) < 0.1) return('0.0 - 0.1')
        else if (as.numeric(x['beta']) < 0.2) return ('0.1 - 0.2')
        else if (as.numeric(x['beta']) < 0.3) return ('0.2 - 0.3')
        else if (as.numeric(x['beta']) < 0.4) return ('0.3 - 0.4')
        else if (as.numeric(x['beta']) < 0.5) return ('0.4 - 0.5')
        else if (as.numeric(x['beta']) < 0.6) return ('0.5 - 0.6')
        else if (as.numeric(x['beta']) < 0.7) return ('0.6 - 0.7')
        else if (as.numeric(x['beta']) < 0.8) return ('0.7 - 0.8')
        else if (as.numeric(x['beta']) < 0.9) return ('0.8 - 0.9')
        else if (as.numeric(x['beta']) <= 1) return ('0.9 - 1.0')
        else return('NA')
    })

    table(curr$beta_categorical)

    p1 <- ggplot(curr[!curr$in_boundary,], aes(x = factor(beta_categorical),
                                         y = factor(hmm), fill = entropy)) +
        geom_tile() + scale_fill_viridis() +
        theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
        xlab(sprintf('%s %s methylation (beta)', samples_dict[item, 'description'], item)) +
        ylab('chromatin color (chromHMM)')

    p2 <- ggplot(curr[!curr$in_boundary,], aes(x = factor(beta_categorical), y = factor(hmm),
                                         fill = standardized_entropy)) +
        geom_tile() + scale_fill_viridis() +
        theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
        xlab(sprintf('%s %s methylation (beta)', samples_dict[item, 'description'], item)) +
        ylab('chromatin color (chromHMM)')


    p3 <-grid.arrange(p1 , p2, ncol = 2)
    p3
    ggsave(sprintf('%s_heat_categorical.png', item), plot = p3, width = 10, height=5)

}

```

# Across samples

What about replicates and cell lines?

```{r}

foo <- list()
for (item in names(d)) {
    curr <- d[[item]]
    curr <- curr[!curr$in_boundary,]
    curr$beta_rounded <- round(curr$beta, 1)

    foo[[item]] <- curr[,c('standardized_entropy', 'hmm')]
    foo[[item]]$id <- paste0(item, '_', samples_dict[item, 'description'])
    
    
   
    
}

foo <- do.call(rbind.data.frame, foo)

foo$id <- factor(foo$id, levels = c('ENCFF079RGH_GM23248',
                                    'ENCFF119ELB_GM23248',
                                    'ENCFF193RVP_HeLa-S3',
                                    'ENCFF845VFH_HeLa-S3',
                                    'ENCFF957OIM_HepG2',
                                    'ENCFF572KNK_HepG2',
                                    'ENCFF112TXF_IMR90'))

    
p <- ggplot(foo, aes(x=id, y=standardized_entropy, fill=hmm)) +
  geom_boxplot() + coord_flip()
                                      
print(p) 
## # Add dots
## p + geom_dotplot(binaxis='y', stackdir='center')


 ## ggplot(data = foo,
 ##           aes(x = id, y = sta, fill = hmm)) +
 ##        geom_bar(stat="identity") +
 ##        theme(text = element_text(size = 15),
 ##              axis.text.x = element_text(angle = 90, hjust = 1))

## foo <- gather(summarized, beta, value, -id, -hmm)

p <- ggplot(data = foo, aes(y = standardized_entropy, x = id)) +
    geom_boxplot()
print(p + facet_wrap(~hmm, nrow = 5) +
    theme(text = element_text(size = 15),
          axis.text.x = element_text(angle = 90, hjust = 1)))

```


Raw entropies

```{r rawentropy}

foo <- list()
for (item in names(d)) {
    curr <- d[[item]]
    curr <- curr[!curr$in_boundary,]
    curr$beta_rounded <- round(curr$beta, 1)

    foo[[item]] <- curr[,c('entropy', 'hmm')]
    foo[[item]]$id <- paste0(item, '_', samples_dict[item, 'description'])
    
    
   
    
}

foo <- do.call(rbind.data.frame, foo)

foo$id <- factor(foo$id, levels = c('ENCFF079RGH_GM23248',
                                    'ENCFF119ELB_GM23248',
                                    'ENCFF193RVP_HeLa-S3',
                                    'ENCFF845VFH_HeLa-S3',
                                    'ENCFF957OIM_HepG2',
                                    'ENCFF572KNK_HepG2',
                                    'ENCFF112TXF_IMR90'))

    
p <- ggplot(foo, aes(x=id, y=entropy, fill=hmm)) +
  geom_boxplot() + coord_flip()
                                      
print(p)

p <- ggplot(data = foo, aes(y = entropy, x = id)) + geom_boxplot()
print(p + facet_wrap(~hmm, nrow = 5) +
    theme(text = element_text(size = 15),
              axis.text.x = element_text(angle = 90, hjust = 1)))

```

# Session

```{r sessioinfo, cache = FALSE}
devtools::session_info()
```
