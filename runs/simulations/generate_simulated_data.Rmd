---
title: "Cometh simulation"
params:
  seed: 1
author: "Izaskun Mallona"
output:
  html_document:
    keep_md: false
    toc: true
    toc_float: true
    toc_depth: 4

---

# Context


# SEt up

```{r tag}
analysis_tag <- 'cometh_simulation'
```

```{r libraries, include=TRUE, cache = FALSE}
library(data.table)
library(entropy)

```

```{r functions}
ac <-  function(col, alpha=1){

    apply(sapply(col, col2rgb)/255, 2, 
          function(x) 
              rgb(x[1], x[2], x[3], alpha=alpha))  
}
```


# Simulation scenarios

Data structure:

```
chr, cpg1, cpg2, tuples, entropies, strand, methylation
```

```
18	10862	10870	MM50;MU0;UM0;UU0	0	+	1
18	10870	10876	MM50;MU0;UM0;UU0	0	+	1
18	10876	10888	MM49;MU0;UM0;UU0	0	+	1
18	48387	48396	MM57;MU0;UM38;UU0	0.673012	-	0.8
18	48396	48398	MM59;MU37;UM0;UU0	0.666654	-	0.807292
18	48398	48412	MM50;MU9;UM37;UU0	0.929138	-	0.760417
18	48412	48434	MM87;MU0;UM9;UU0	0.311129	-	0.953125


```

## Fully methylated

⏺⏺

⏺⏺

⏺⏺

⏺⏺

```{r}

## ## not used
## recurse <- function(positions) {
##     positions <- sort(positions)
##     n <- 1
##     res <- NULL
##     while (n <= length(positions)) {
##         if (n == 1) {
##             res <- c(res, positions[n])
##         } else {
##             ## print(sprintf('%s %s %s', n, positions[n-1], positions[n]))
##             res <- c(res, positions[n-1] + positions[n])
##         }
##         n <- n + 1
##     }

##     res
## }

## recurse(1:10)
## recurse(10:1)
## recurse(c(5,5,500))


get_methylation <- function(mm, um, mu, uu) {
    return (( (2 * mm) + um + mu) / (2* ( mm + um + mu + uu) ))
}

get_tuple_name <- function(mm, um, mu, uu) {
    sprintf('MM%s;MU%s;UM%s;UU%s', mm, mu, um, uu)
}


fill_positions_no_gaps <- function(num_tuples, tuple_distance) {

    pos <- seq(from = 1, length.out = num_tuples, by = tuple_distance)
    
    end <- c(pos[2:length(pos)], pos[length(pos)] + tuple_distance)

    return(list(start = pos, end = end))
}

build_tuple_scaffold <- function(num_tuples) {
    tmp <- as.data.frame(matrix(nrow = num_tuples, ncol = 10, data = NA))
    colnames(tmp) <- c('chrom', 'start', 'end', 'MM', 'MU', 'UM', 'UU', 'entropy',
                       'strand', 'meth')
    tmp
}

## no gaps between tuples
simulate_full_meth <- function(chrom, num_tuples, average_depth, std_depth, tuple_distance) {
    d <- build_tuple_scaffold(num_tuples)
    d[,'chrom'] <- chrom
    
    ## one sided, rounded normal distribution for coverages
    set.seed(1)
    d[,'MM'] <- round(abs(rnorm(n = num_tuples,
                              mean = average_depth,
                              sd = std_depth)))
    d[d$MM == 0, 'MM'] <- average_depth
    
    foo <- fill_positions_no_gaps(num_tuples = num_tuples,
                                            tuple_distance = tuple_distance)

    d$start <- foo$start
    d$end <- foo$end

    ## at random
    set.seed(4)
    d[,'strand'] <- sample(c('+', '-'), size = num_tuples, replace = TRUE)
    
    d[,'UU'] <- 0
    d[,'UM'] <- 0
    d[,'MU'] <- 0

    d[,'meth'] <- get_methylation(mm = d$MM, um = d$UM,
                                    mu = d$MU, uu = d$UU)

    d[, 'entropy'] <- apply(d[c('MM', 'UM', 'MU', 'UU')],
                              1,
                              entropy)
    
    d$id <- get_tuple_name(mm = d$MM, um = d$UM, mu = d$MU, uu = d$UU)
    
    d[c('chrom', 'start', 'end', 'id', 'entropy', 'strand', 'meth' )]
                    
}
```

```{r}
meth <- simulate_full_meth(chrom = 'chr19', num_tuples = 10000,
                           average_depth = 10,
                           std_depth = 5,
                           tuple_distance = 20)

summary(meth)
```

## Fully unmethylated

○○

○○

○○

○○

```{r}

simulate_full_unmeth <- function(chrom, num_tuples, average_depth, std_depth, tuple_distance) {
    d <- build_tuple_scaffold(num_tuples)
    d[,'chrom'] <- chrom
    
    ## one sided, rounded normal distribution for coverages
    set.seed(1)
    d[,'UU'] <- round(abs(rnorm(n = num_tuples,
                                  mean = average_depth,
                                  sd = std_depth)))
    d[d$UU == 0, 'UU'] <- average_depth

    foo <- fill_positions_no_gaps(num_tuples = num_tuples,
                                            tuple_distance = tuple_distance)

    d$start <- foo$start
    d$end <- foo$end
    
    ## at random
    set.seed(4)
    d[,'strand'] <- sample(c('+', '-'), size = num_tuples, replace = TRUE)
    
    d[,'MM'] <- 0
    d[,'UM'] <- 0
    d[,'MU'] <- 0

    d[,'meth'] <- get_methylation(mm = d$MM, um = d$UM,
                                    mu = d$MU, uu = d$UU)

    d[, 'entropy'] <- apply(d[c('MM', 'UM', 'MU', 'UU')],
                              1,
                              entropy)
    
    d$id <- get_tuple_name(mm = d$MM, um = d$UM, mu = d$MU, uu = d$UU)
    
    d[c('chrom', 'start', 'end', 'id', 'entropy', 'strand', 'meth' )]            
}


```

```{r}
unmeth <- simulate_full_unmeth(chrom = 'chr19', num_tuples = 10000,
                               average_depth = 10,
                               std_depth = 5,
                               tuple_distance = 20)

summary(unmeth)
```

## Two haplotypes, half methylation, ordered

⏺⏺

⏺⏺

○○

○○


```{r}
simulate_two_haplotypes_lowest_entropy <- function(chrom, num_tuples, average_depth,
                                                   std_depth, tuple_distance) {

    dmeth <- simulate_full_meth(chrom, round(num_tuples/2), average_depth,
                                std_depth, tuple_distance)
    ## print(head(dmeth))

    dunmeth <-  simulate_full_unmeth(chrom, round(num_tuples/2), average_depth,
                                     std_depth, tuple_distance)

    ## print(head(dunmeth))
    
    d <- rbind(dmeth, dunmeth)

    d <- d[order(d$start),]
    d
    ## return(list(d = d, dmeth = dmeth, dunmeth = dunmeth))
}

```


```{r}
imprint <- simulate_two_haplotypes_lowest_entropy(chrom = 'chr19', num_tuples = 10000,
                               average_depth = 10,
                               std_depth = 5,
                               tuple_distance = 20)

summary(imprint)

```


## Infinite haplotypes, max entropy


```{r untested1, eval = FALSE}

simulate_infinite_haplotypes <- function(chrom, num_tuples, average_depth,
                                         std_depth, tuple_distance) {

    d <- build_tuple_scaffold(num_tuples)
    d[,'chrom'] <- chrom
    
    ## one sided, rounded normal distribution for coverages
    set.seed(1)
    
    d[,'UU'] <- round(abs(rnorm(n = num_tuples,
                                  mean = average_depth/4,
                                  sd = std_depth)))

    d[,'UM'] <- round(abs(rnorm(n = num_tuples,
                                  mean = average_depth/4,
                                  sd = std_depth)))
    d[,'MU'] <- round(abs(rnorm(n = num_tuples,
                                  mean = average_depth/4,
                                sd = std_depth)))
    d[,'UM'] <- round(abs(rnorm(n = num_tuples,
                                  mean = average_depth/4,
                                sd = std_depth)))
    
    foo <- fill_positions_no_gaps(num_tuples = num_tuples,
                                            tuple_distance = tuple_distance)

    d$start <- foo$start
    d$end <- foo$end
    
    ## at random
    set.seed(4)
    d[,'strand'] <- sample(c('+', '-'), size = num_tuples, replace = TRUE)
    d
    
}
```

```{r untested2, eval = FALSE}
entropic <- simulate_infinite_haplotypes(chrom = 'chr19', num_tuples = 10000,
                               average_depth = 10,
                               std_depth = 5,
                               tuple_distance = 20)

summary(entropic)

```
## Boundary

# Todo

Simulating regions longer than 2 items?

Strand-specific simulations?

# Session

```{r sessionInfo, cache = 0}

date()
devtools::session_info()

```
